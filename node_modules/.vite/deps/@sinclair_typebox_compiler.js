import {
  require_typebox
} from "./chunk-EPQSP7KV.js";
import {
  __commonJS
} from "./chunk-OSJZHPF7.js";

// node_modules/@sinclair/typebox/system/system.js
var require_system = __commonJS({
  "node_modules/@sinclair/typebox/system/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;
    var Types = require_typebox();
    var TypeSystemDuplicateTypeKind = class extends Error {
      constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
    var TypeSystemDuplicateFormat = class extends Error {
      constructor(kind) {
        super(`Duplicate string format '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
    var TypeSystem;
    (function(TypeSystem2) {
      TypeSystem2.ExactOptionalPropertyTypes = false;
      TypeSystem2.AllowArrayObjects = false;
      TypeSystem2.AllowNaN = false;
      TypeSystem2.AllowVoidNull = false;
      function Type(kind, check) {
        if (Types.TypeRegistry.Has(kind))
          throw new TypeSystemDuplicateTypeKind(kind);
        Types.TypeRegistry.Set(kind, check);
        return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });
      }
      TypeSystem2.Type = Type;
      function Format(format, check) {
        if (Types.FormatRegistry.Has(format))
          throw new TypeSystemDuplicateFormat(format);
        Types.FormatRegistry.Set(format, check);
        return format;
      }
      TypeSystem2.Format = Format;
      function CreateType(kind, check) {
        return Type(kind, check);
      }
      TypeSystem2.CreateType = CreateType;
      function CreateFormat(format, check) {
        return Format(format, check);
      }
      TypeSystem2.CreateFormat = CreateFormat;
    })(TypeSystem = exports.TypeSystem || (exports.TypeSystem = {}));
  }
});

// node_modules/@sinclair/typebox/system/index.js
var require_system2 = __commonJS({
  "node_modules/@sinclair/typebox/system/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_system(), exports);
  }
});

// node_modules/@sinclair/typebox/value/hash.js
var require_hash = __commonJS({
  "node_modules/@sinclair/typebox/value/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueHash = exports.ValueHashError = void 0;
    var ValueHashError = class extends Error {
      constructor(value) {
        super(`Hash: Unable to hash value`);
        this.value = value;
      }
    };
    exports.ValueHashError = ValueHashError;
    var ValueHash;
    (function(ValueHash2) {
      let ByteMarker;
      (function(ByteMarker2) {
        ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
        ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
        ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
        ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
        ByteMarker2[ByteMarker2["String"] = 4] = "String";
        ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
        ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
        ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
        ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
        ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
        ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
      })(ByteMarker || (ByteMarker = {}));
      let Hash = globalThis.BigInt("14695981039346656037");
      const [Prime, Size] = [globalThis.BigInt("1099511628211"), globalThis.BigInt("2") ** globalThis.BigInt("64")];
      const Bytes = globalThis.Array.from({ length: 256 }).map((_, i) => globalThis.BigInt(i));
      const F64 = new globalThis.Float64Array(1);
      const F64In = new globalThis.DataView(F64.buffer);
      const F64Out = new globalThis.Uint8Array(F64.buffer);
      function IsDate(value) {
        return value instanceof globalThis.Date;
      }
      function IsUint8Array(value) {
        return value instanceof globalThis.Uint8Array;
      }
      function IsArray(value) {
        return globalThis.Array.isArray(value);
      }
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      function IsNull(value) {
        return value === null;
      }
      function IsNumber(value) {
        return typeof value === "number";
      }
      function IsSymbol(value) {
        return typeof value === "symbol";
      }
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      function IsObject(value) {
        return typeof value === "object" && value !== null && !IsArray(value) && !IsDate(value) && !IsUint8Array(value);
      }
      function IsString(value) {
        return typeof value === "string";
      }
      function IsUndefined(value) {
        return value === void 0;
      }
      function Array(value) {
        FNV1A64(ByteMarker.Array);
        for (const item of value) {
          Visit(item);
        }
      }
      function Boolean(value) {
        FNV1A64(ByteMarker.Boolean);
        FNV1A64(value ? 1 : 0);
      }
      function BigInt(value) {
        FNV1A64(ByteMarker.BigInt);
        F64In.setBigInt64(0, value);
        for (const byte of F64Out) {
          FNV1A64(byte);
        }
      }
      function Date(value) {
        FNV1A64(ByteMarker.Date);
        Visit(value.getTime());
      }
      function Null(value) {
        FNV1A64(ByteMarker.Null);
      }
      function Number(value) {
        FNV1A64(ByteMarker.Number);
        F64In.setFloat64(0, value);
        for (const byte of F64Out) {
          FNV1A64(byte);
        }
      }
      function Object2(value) {
        FNV1A64(ByteMarker.Object);
        for (const key of globalThis.Object.keys(value).sort()) {
          Visit(key);
          Visit(value[key]);
        }
      }
      function String(value) {
        FNV1A64(ByteMarker.String);
        for (let i = 0; i < value.length; i++) {
          FNV1A64(value.charCodeAt(i));
        }
      }
      function Symbol2(value) {
        FNV1A64(ByteMarker.Symbol);
        Visit(value.description);
      }
      function Uint8Array(value) {
        FNV1A64(ByteMarker.Uint8Array);
        for (let i = 0; i < value.length; i++) {
          FNV1A64(value[i]);
        }
      }
      function Undefined(value) {
        return FNV1A64(ByteMarker.Undefined);
      }
      function Visit(value) {
        if (IsArray(value)) {
          Array(value);
        } else if (IsBoolean(value)) {
          Boolean(value);
        } else if (IsBigInt(value)) {
          BigInt(value);
        } else if (IsDate(value)) {
          Date(value);
        } else if (IsNull(value)) {
          Null(value);
        } else if (IsNumber(value)) {
          Number(value);
        } else if (IsObject(value)) {
          Object2(value);
        } else if (IsString(value)) {
          String(value);
        } else if (IsSymbol(value)) {
          Symbol2(value);
        } else if (IsUint8Array(value)) {
          Uint8Array(value);
        } else if (IsUndefined(value)) {
          Undefined(value);
        } else {
          throw new ValueHashError(value);
        }
      }
      function FNV1A64(byte) {
        Hash = Hash ^ Bytes[byte];
        Hash = Hash * Prime % Size;
      }
      function Create(value) {
        Hash = globalThis.BigInt("14695981039346656037");
        Visit(value);
        return Hash;
      }
      ValueHash2.Create = Create;
    })(ValueHash = exports.ValueHash || (exports.ValueHash = {}));
  }
});

// node_modules/@sinclair/typebox/errors/errors.js
var require_errors = __commonJS({
  "node_modules/@sinclair/typebox/errors/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrors = exports.ValueErrorsDereferenceError = exports.ValueErrorsUnknownTypeError = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
    var Types = require_typebox();
    var index_1 = require_system2();
    var hash_1 = require_hash();
    var ValueErrorType;
    (function(ValueErrorType2) {
      ValueErrorType2[ValueErrorType2["Array"] = 0] = "Array";
      ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 1] = "ArrayMinItems";
      ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
      ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 3] = "ArrayUniqueItems";
      ValueErrorType2[ValueErrorType2["BigInt"] = 4] = "BigInt";
      ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 5] = "BigIntMultipleOf";
      ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 6] = "BigIntExclusiveMinimum";
      ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 7] = "BigIntExclusiveMaximum";
      ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 8] = "BigIntMinimum";
      ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 9] = "BigIntMaximum";
      ValueErrorType2[ValueErrorType2["Boolean"] = 10] = "Boolean";
      ValueErrorType2[ValueErrorType2["Date"] = 11] = "Date";
      ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 12] = "DateExclusiveMinimumTimestamp";
      ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 13] = "DateExclusiveMaximumTimestamp";
      ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 14] = "DateMinimumTimestamp";
      ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 15] = "DateMaximumTimestamp";
      ValueErrorType2[ValueErrorType2["Function"] = 16] = "Function";
      ValueErrorType2[ValueErrorType2["Integer"] = 17] = "Integer";
      ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 18] = "IntegerMultipleOf";
      ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 19] = "IntegerExclusiveMinimum";
      ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 20] = "IntegerExclusiveMaximum";
      ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 21] = "IntegerMinimum";
      ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 22] = "IntegerMaximum";
      ValueErrorType2[ValueErrorType2["Intersect"] = 23] = "Intersect";
      ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 24] = "IntersectUnevaluatedProperties";
      ValueErrorType2[ValueErrorType2["Literal"] = 25] = "Literal";
      ValueErrorType2[ValueErrorType2["Never"] = 26] = "Never";
      ValueErrorType2[ValueErrorType2["Not"] = 27] = "Not";
      ValueErrorType2[ValueErrorType2["Null"] = 28] = "Null";
      ValueErrorType2[ValueErrorType2["Number"] = 29] = "Number";
      ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 30] = "NumberMultipleOf";
      ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 31] = "NumberExclusiveMinimum";
      ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 32] = "NumberExclusiveMaximum";
      ValueErrorType2[ValueErrorType2["NumberMinumum"] = 33] = "NumberMinumum";
      ValueErrorType2[ValueErrorType2["NumberMaximum"] = 34] = "NumberMaximum";
      ValueErrorType2[ValueErrorType2["Object"] = 35] = "Object";
      ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 36] = "ObjectMinProperties";
      ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 37] = "ObjectMaxProperties";
      ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 38] = "ObjectAdditionalProperties";
      ValueErrorType2[ValueErrorType2["ObjectRequiredProperties"] = 39] = "ObjectRequiredProperties";
      ValueErrorType2[ValueErrorType2["Promise"] = 40] = "Promise";
      ValueErrorType2[ValueErrorType2["RecordKeyNumeric"] = 41] = "RecordKeyNumeric";
      ValueErrorType2[ValueErrorType2["RecordKeyString"] = 42] = "RecordKeyString";
      ValueErrorType2[ValueErrorType2["String"] = 43] = "String";
      ValueErrorType2[ValueErrorType2["StringMinLength"] = 44] = "StringMinLength";
      ValueErrorType2[ValueErrorType2["StringMaxLength"] = 45] = "StringMaxLength";
      ValueErrorType2[ValueErrorType2["StringPattern"] = 46] = "StringPattern";
      ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 47] = "StringFormatUnknown";
      ValueErrorType2[ValueErrorType2["StringFormat"] = 48] = "StringFormat";
      ValueErrorType2[ValueErrorType2["Symbol"] = 49] = "Symbol";
      ValueErrorType2[ValueErrorType2["TupleZeroLength"] = 50] = "TupleZeroLength";
      ValueErrorType2[ValueErrorType2["TupleLength"] = 51] = "TupleLength";
      ValueErrorType2[ValueErrorType2["Undefined"] = 52] = "Undefined";
      ValueErrorType2[ValueErrorType2["Union"] = 53] = "Union";
      ValueErrorType2[ValueErrorType2["Uint8Array"] = 54] = "Uint8Array";
      ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 55] = "Uint8ArrayMinByteLength";
      ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 56] = "Uint8ArrayMaxByteLength";
      ValueErrorType2[ValueErrorType2["Void"] = 57] = "Void";
      ValueErrorType2[ValueErrorType2["Custom"] = 58] = "Custom";
    })(ValueErrorType = exports.ValueErrorType || (exports.ValueErrorType = {}));
    var ValueErrorIterator = class {
      constructor(iterator) {
        this.iterator = iterator;
      }
      [Symbol.iterator]() {
        return this.iterator;
      }
      /** Returns the first value error or undefined if no errors */
      First() {
        const next = this.iterator.next();
        return next.done ? void 0 : next.value;
      }
    };
    exports.ValueErrorIterator = ValueErrorIterator;
    var ValueErrorsUnknownTypeError = class extends Error {
      constructor(schema) {
        super("ValueErrors: Unknown type");
        this.schema = schema;
      }
    };
    exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
    var ValueErrorsDereferenceError = class extends Error {
      constructor(schema) {
        super(`ValueErrors: Unable to dereference schema with $id '${schema.$ref}'`);
        this.schema = schema;
      }
    };
    exports.ValueErrorsDereferenceError = ValueErrorsDereferenceError;
    var ValueErrors;
    (function(ValueErrors2) {
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      function IsInteger(value) {
        return globalThis.Number.isInteger(value);
      }
      function IsString(value) {
        return typeof value === "string";
      }
      function IsDefined(value) {
        return value !== void 0;
      }
      function IsExactOptionalProperty(value, key) {
        return index_1.TypeSystem.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
      }
      function IsObject(value) {
        const result = typeof value === "object" && value !== null;
        return index_1.TypeSystem.AllowArrayObjects ? result : result && !globalThis.Array.isArray(value);
      }
      function IsRecordObject(value) {
        return IsObject(value) && !(value instanceof globalThis.Date) && !(value instanceof globalThis.Uint8Array);
      }
      function IsNumber(value) {
        const result = typeof value === "number";
        return index_1.TypeSystem.AllowNaN ? result : result && globalThis.Number.isFinite(value);
      }
      function IsVoid(value) {
        const result = value === void 0;
        return index_1.TypeSystem.AllowVoidNull ? result || value === null : result;
      }
      function* Any(schema, references, path, value) {
      }
      function* Array(schema, references, path, value) {
        if (!globalThis.Array.isArray(value)) {
          return yield { type: ValueErrorType.Array, schema, path, value, message: `Expected array` };
        }
        if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
          yield { type: ValueErrorType.ArrayMinItems, schema, path, value, message: `Expected array length to be greater or equal to ${schema.minItems}` };
        }
        if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
          yield { type: ValueErrorType.ArrayMinItems, schema, path, value, message: `Expected array length to be less or equal to ${schema.maxItems}` };
        }
        if (schema.uniqueItems === true && !function() {
          const set = /* @__PURE__ */ new Set();
          for (const element of value) {
            const hashed = hash_1.ValueHash.Create(element);
            if (set.has(hashed)) {
              return false;
            } else {
              set.add(hashed);
            }
          }
          return true;
        }()) {
          yield { type: ValueErrorType.ArrayUniqueItems, schema, path, value, message: `Expected array elements to be unique` };
        }
        for (let i = 0; i < value.length; i++) {
          yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
        }
      }
      function* BigInt(schema, references, path, value) {
        if (!IsBigInt(value)) {
          return yield { type: ValueErrorType.BigInt, schema, path, value, message: `Expected bigint` };
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === globalThis.BigInt(0))) {
          yield { type: ValueErrorType.BigIntMultipleOf, schema, path, value, message: `Expected bigint to be a multiple of ${schema.multipleOf}` };
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          yield { type: ValueErrorType.BigIntExclusiveMinimum, schema, path, value, message: `Expected bigint to be greater than ${schema.exclusiveMinimum}` };
        }
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          yield { type: ValueErrorType.BigIntExclusiveMaximum, schema, path, value, message: `Expected bigint to be less than ${schema.exclusiveMaximum}` };
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          yield { type: ValueErrorType.BigIntMinimum, schema, path, value, message: `Expected bigint to be greater or equal to ${schema.minimum}` };
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          yield { type: ValueErrorType.BigIntMaximum, schema, path, value, message: `Expected bigint to be less or equal to ${schema.maximum}` };
        }
      }
      function* Boolean(schema, references, path, value) {
        if (!(typeof value === "boolean")) {
          return yield { type: ValueErrorType.Boolean, schema, path, value, message: `Expected boolean` };
        }
      }
      function* Constructor(schema, references, path, value) {
        yield* Visit(schema.returns, references, path, value.prototype);
      }
      function* Date(schema, references, path, value) {
        if (!(value instanceof globalThis.Date)) {
          return yield { type: ValueErrorType.Date, schema, path, value, message: `Expected Date object` };
        }
        if (!globalThis.isFinite(value.getTime())) {
          return yield { type: ValueErrorType.Date, schema, path, value, message: `Invalid Date` };
        }
        if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
          yield { type: ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value, message: `Expected Date timestamp to be greater than ${schema.exclusiveMinimum}` };
        }
        if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
          yield { type: ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value, message: `Expected Date timestamp to be less than ${schema.exclusiveMaximum}` };
        }
        if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
          yield { type: ValueErrorType.DateMinimumTimestamp, schema, path, value, message: `Expected Date timestamp to be greater or equal to ${schema.minimum}` };
        }
        if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
          yield { type: ValueErrorType.DateMaximumTimestamp, schema, path, value, message: `Expected Date timestamp to be less or equal to ${schema.maximum}` };
        }
      }
      function* Function(schema, references, path, value) {
        if (!(typeof value === "function")) {
          return yield { type: ValueErrorType.Function, schema, path, value, message: `Expected function` };
        }
      }
      function* Integer(schema, references, path, value) {
        if (!IsInteger(value)) {
          return yield { type: ValueErrorType.Integer, schema, path, value, message: `Expected integer` };
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
          yield { type: ValueErrorType.IntegerMultipleOf, schema, path, value, message: `Expected integer to be a multiple of ${schema.multipleOf}` };
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          yield { type: ValueErrorType.IntegerExclusiveMinimum, schema, path, value, message: `Expected integer to be greater than ${schema.exclusiveMinimum}` };
        }
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          yield { type: ValueErrorType.IntegerExclusiveMaximum, schema, path, value, message: `Expected integer to be less than ${schema.exclusiveMaximum}` };
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          yield { type: ValueErrorType.IntegerMinimum, schema, path, value, message: `Expected integer to be greater or equal to ${schema.minimum}` };
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          yield { type: ValueErrorType.IntegerMaximum, schema, path, value, message: `Expected integer to be less or equal to ${schema.maximum}` };
        }
      }
      function* Intersect(schema, references, path, value) {
        for (const subschema of schema.allOf) {
          const next = Visit(subschema, references, path, value).next();
          if (!next.done) {
            yield next.value;
            yield { type: ValueErrorType.Intersect, schema, path, value, message: `Expected all sub schemas to be valid` };
            return;
          }
        }
        if (schema.unevaluatedProperties === false) {
          const schemaKeys = Types.KeyResolver.Resolve(schema);
          const valueKeys = globalThis.Object.getOwnPropertyNames(value);
          for (const valueKey of valueKeys) {
            if (!schemaKeys.includes(valueKey)) {
              yield { type: ValueErrorType.IntersectUnevaluatedProperties, schema, path: `${path}/${valueKey}`, value, message: `Unexpected property` };
            }
          }
        }
        if (typeof schema.unevaluatedProperties === "object") {
          const schemaKeys = Types.KeyResolver.Resolve(schema);
          const valueKeys = globalThis.Object.getOwnPropertyNames(value);
          for (const valueKey of valueKeys) {
            if (!schemaKeys.includes(valueKey)) {
              const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
              if (!next.done) {
                yield next.value;
                yield { type: ValueErrorType.IntersectUnevaluatedProperties, schema, path: `${path}/${valueKey}`, value, message: `Invalid additional property` };
                return;
              }
            }
          }
        }
      }
      function* Literal(schema, references, path, value) {
        if (!(value === schema.const)) {
          const error = typeof schema.const === "string" ? `'${schema.const}'` : schema.const;
          return yield { type: ValueErrorType.Literal, schema, path, value, message: `Expected ${error}` };
        }
      }
      function* Never(schema, references, path, value) {
        yield { type: ValueErrorType.Never, schema, path, value, message: `Value cannot be validated` };
      }
      function* Not(schema, references, path, value) {
        if (Visit(schema.allOf[0].not, references, path, value).next().done === true) {
          yield { type: ValueErrorType.Not, schema, path, value, message: `Value should not validate` };
        }
        yield* Visit(schema.allOf[1], references, path, value);
      }
      function* Null(schema, references, path, value) {
        if (!(value === null)) {
          return yield { type: ValueErrorType.Null, schema, path, value, message: `Expected null` };
        }
      }
      function* Number(schema, references, path, value) {
        if (!IsNumber(value)) {
          return yield { type: ValueErrorType.Number, schema, path, value, message: `Expected number` };
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
          yield { type: ValueErrorType.NumberMultipleOf, schema, path, value, message: `Expected number to be a multiple of ${schema.multipleOf}` };
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
          yield { type: ValueErrorType.NumberExclusiveMinimum, schema, path, value, message: `Expected number to be greater than ${schema.exclusiveMinimum}` };
        }
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
          yield { type: ValueErrorType.NumberExclusiveMaximum, schema, path, value, message: `Expected number to be less than ${schema.exclusiveMaximum}` };
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
          yield { type: ValueErrorType.NumberMaximum, schema, path, value, message: `Expected number to be greater or equal to ${schema.minimum}` };
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
          yield { type: ValueErrorType.NumberMinumum, schema, path, value, message: `Expected number to be less or equal to ${schema.maximum}` };
        }
      }
      function* Object2(schema, references, path, value) {
        if (!IsObject(value)) {
          return yield { type: ValueErrorType.Object, schema, path, value, message: `Expected object` };
        }
        if (IsDefined(schema.minProperties) && !(globalThis.Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
          yield { type: ValueErrorType.ObjectMinProperties, schema, path, value, message: `Expected object to have at least ${schema.minProperties} properties` };
        }
        if (IsDefined(schema.maxProperties) && !(globalThis.Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
          yield { type: ValueErrorType.ObjectMaxProperties, schema, path, value, message: `Expected object to have less than ${schema.minProperties} properties` };
        }
        const requiredKeys = globalThis.Array.isArray(schema.required) ? schema.required : [];
        const knownKeys = globalThis.Object.getOwnPropertyNames(schema.properties);
        const unknownKeys = globalThis.Object.getOwnPropertyNames(value);
        for (const knownKey of knownKeys) {
          const property = schema.properties[knownKey];
          if (schema.required && schema.required.includes(knownKey)) {
            yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);
            if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {
              yield { type: ValueErrorType.ObjectRequiredProperties, schema: property, path: `${path}/${knownKey}`, value: void 0, message: `Expected required property` };
            }
          } else {
            if (IsExactOptionalProperty(value, knownKey)) {
              yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);
            }
          }
        }
        for (const requiredKey of requiredKeys) {
          if (unknownKeys.includes(requiredKey))
            continue;
          yield { type: ValueErrorType.ObjectRequiredProperties, schema: schema.properties[requiredKey], path: `${path}/${requiredKey}`, value: void 0, message: `Expected required property` };
        }
        if (schema.additionalProperties === false) {
          for (const valueKey of unknownKeys) {
            if (!knownKeys.includes(valueKey)) {
              yield { type: ValueErrorType.ObjectAdditionalProperties, schema, path: `${path}/${valueKey}`, value: value[valueKey], message: `Unexpected property` };
            }
          }
        }
        if (typeof schema.additionalProperties === "object") {
          for (const valueKey of unknownKeys) {
            if (knownKeys.includes(valueKey))
              continue;
            yield* Visit(schema.additionalProperties, references, `${path}/${valueKey}`, value[valueKey]);
          }
        }
      }
      function* Promise2(schema, references, path, value) {
        if (!(typeof value === "object" && typeof value.then === "function")) {
          yield { type: ValueErrorType.Promise, schema, path, value, message: `Expected Promise` };
        }
      }
      function* Record(schema, references, path, value) {
        if (!IsRecordObject(value)) {
          return yield { type: ValueErrorType.Object, schema, path, value, message: `Expected record object` };
        }
        if (IsDefined(schema.minProperties) && !(globalThis.Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
          yield { type: ValueErrorType.ObjectMinProperties, schema, path, value, message: `Expected object to have at least ${schema.minProperties} properties` };
        }
        if (IsDefined(schema.maxProperties) && !(globalThis.Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
          yield { type: ValueErrorType.ObjectMaxProperties, schema, path, value, message: `Expected object to have less than ${schema.minProperties} properties` };
        }
        const [keyPattern, valueSchema] = globalThis.Object.entries(schema.patternProperties)[0];
        const regex = new RegExp(keyPattern);
        if (!globalThis.Object.getOwnPropertyNames(value).every((key) => regex.test(key))) {
          const numeric = keyPattern === Types.PatternNumberExact;
          const type = numeric ? ValueErrorType.RecordKeyNumeric : ValueErrorType.RecordKeyString;
          const message = numeric ? "Expected all object property keys to be numeric" : "Expected all object property keys to be strings";
          return yield { type, schema, path, value, message };
        }
        for (const [propKey, propValue] of globalThis.Object.entries(value)) {
          yield* Visit(valueSchema, references, `${path}/${propKey}`, propValue);
        }
      }
      function* Ref(schema, references, path, value) {
        const index = references.findIndex((foreign) => foreign.$id === schema.$ref);
        if (index === -1)
          throw new ValueErrorsDereferenceError(schema);
        const target = references[index];
        yield* Visit(target, references, path, value);
      }
      function* String(schema, references, path, value) {
        if (!IsString(value)) {
          return yield { type: ValueErrorType.String, schema, path, value, message: "Expected string" };
        }
        if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
          yield { type: ValueErrorType.StringMinLength, schema, path, value, message: `Expected string length greater or equal to ${schema.minLength}` };
        }
        if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
          yield { type: ValueErrorType.StringMaxLength, schema, path, value, message: `Expected string length less or equal to ${schema.maxLength}` };
        }
        if (schema.pattern !== void 0) {
          const regex = new RegExp(schema.pattern);
          if (!regex.test(value)) {
            yield { type: ValueErrorType.StringPattern, schema, path, value, message: `Expected string to match pattern ${schema.pattern}` };
          }
        }
        if (schema.format !== void 0) {
          if (!Types.FormatRegistry.Has(schema.format)) {
            yield { type: ValueErrorType.StringFormatUnknown, schema, path, value, message: `Unknown string format '${schema.format}'` };
          } else {
            const format = Types.FormatRegistry.Get(schema.format);
            if (!format(value)) {
              yield { type: ValueErrorType.StringFormat, schema, path, value, message: `Expected string to match format '${schema.format}'` };
            }
          }
        }
      }
      function* Symbol2(schema, references, path, value) {
        if (!(typeof value === "symbol")) {
          return yield { type: ValueErrorType.Symbol, schema, path, value, message: "Expected symbol" };
        }
      }
      function* TemplateLiteral(schema, references, path, value) {
        if (!IsString(value)) {
          return yield { type: ValueErrorType.String, schema, path, value, message: "Expected string" };
        }
        const regex = new RegExp(schema.pattern);
        if (!regex.test(value)) {
          yield { type: ValueErrorType.StringPattern, schema, path, value, message: `Expected string to match pattern ${schema.pattern}` };
        }
      }
      function* This(schema, references, path, value) {
        const index = references.findIndex((foreign) => foreign.$id === schema.$ref);
        if (index === -1)
          throw new ValueErrorsDereferenceError(schema);
        const target = references[index];
        yield* Visit(target, references, path, value);
      }
      function* Tuple(schema, references, path, value) {
        if (!globalThis.Array.isArray(value)) {
          return yield { type: ValueErrorType.Array, schema, path, value, message: "Expected Array" };
        }
        if (schema.items === void 0 && !(value.length === 0)) {
          return yield { type: ValueErrorType.TupleZeroLength, schema, path, value, message: "Expected tuple to have 0 elements" };
        }
        if (!(value.length === schema.maxItems)) {
          yield { type: ValueErrorType.TupleLength, schema, path, value, message: `Expected tuple to have ${schema.maxItems} elements` };
        }
        if (!schema.items) {
          return;
        }
        for (let i = 0; i < schema.items.length; i++) {
          yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
        }
      }
      function* Undefined(schema, references, path, value) {
        if (!(value === void 0)) {
          yield { type: ValueErrorType.Undefined, schema, path, value, message: `Expected undefined` };
        }
      }
      function* Union(schema, references, path, value) {
        const errors = [];
        for (const inner of schema.anyOf) {
          const variantErrors = [...Visit(inner, references, path, value)];
          if (variantErrors.length === 0)
            return;
          errors.push(...variantErrors);
        }
        if (errors.length > 0) {
          yield { type: ValueErrorType.Union, schema, path, value, message: "Expected value of union" };
        }
        for (const error of errors) {
          yield error;
        }
      }
      function* Uint8Array(schema, references, path, value) {
        if (!(value instanceof globalThis.Uint8Array)) {
          return yield { type: ValueErrorType.Uint8Array, schema, path, value, message: `Expected Uint8Array` };
        }
        if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
          yield { type: ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value, message: `Expected Uint8Array to have a byte length less or equal to ${schema.maxByteLength}` };
        }
        if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
          yield { type: ValueErrorType.Uint8ArrayMinByteLength, schema, path, value, message: `Expected Uint8Array to have a byte length greater or equal to ${schema.maxByteLength}` };
        }
      }
      function* Unknown(schema, references, path, value) {
      }
      function* Void(schema, references, path, value) {
        if (!IsVoid(value)) {
          return yield { type: ValueErrorType.Void, schema, path, value, message: `Expected void` };
        }
      }
      function* UserDefined(schema, references, path, value) {
        const check = Types.TypeRegistry.Get(schema[Types.Kind]);
        if (!check(schema, value)) {
          return yield { type: ValueErrorType.Custom, schema, path, value, message: `Expected kind ${schema[Types.Kind]}` };
        }
      }
      function* Visit(schema, references, path, value) {
        const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema_[Types.Kind]) {
          case "Any":
            return yield* Any(schema_, references_, path, value);
          case "Array":
            return yield* Array(schema_, references_, path, value);
          case "BigInt":
            return yield* BigInt(schema_, references_, path, value);
          case "Boolean":
            return yield* Boolean(schema_, references_, path, value);
          case "Constructor":
            return yield* Constructor(schema_, references_, path, value);
          case "Date":
            return yield* Date(schema_, references_, path, value);
          case "Function":
            return yield* Function(schema_, references_, path, value);
          case "Integer":
            return yield* Integer(schema_, references_, path, value);
          case "Intersect":
            return yield* Intersect(schema_, references_, path, value);
          case "Literal":
            return yield* Literal(schema_, references_, path, value);
          case "Never":
            return yield* Never(schema_, references_, path, value);
          case "Not":
            return yield* Not(schema_, references_, path, value);
          case "Null":
            return yield* Null(schema_, references_, path, value);
          case "Number":
            return yield* Number(schema_, references_, path, value);
          case "Object":
            return yield* Object2(schema_, references_, path, value);
          case "Promise":
            return yield* Promise2(schema_, references_, path, value);
          case "Record":
            return yield* Record(schema_, references_, path, value);
          case "Ref":
            return yield* Ref(schema_, references_, path, value);
          case "String":
            return yield* String(schema_, references_, path, value);
          case "Symbol":
            return yield* Symbol2(schema_, references_, path, value);
          case "TemplateLiteral":
            return yield* TemplateLiteral(schema_, references_, path, value);
          case "This":
            return yield* This(schema_, references_, path, value);
          case "Tuple":
            return yield* Tuple(schema_, references_, path, value);
          case "Undefined":
            return yield* Undefined(schema_, references_, path, value);
          case "Union":
            return yield* Union(schema_, references_, path, value);
          case "Uint8Array":
            return yield* Uint8Array(schema_, references_, path, value);
          case "Unknown":
            return yield* Unknown(schema_, references_, path, value);
          case "Void":
            return yield* Void(schema_, references_, path, value);
          default:
            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
              throw new ValueErrorsUnknownTypeError(schema);
            return yield* UserDefined(schema_, references_, path, value);
        }
      }
      function Errors(schema, references, value) {
        const iterator = Visit(schema, references, "", value);
        return new ValueErrorIterator(iterator);
      }
      ValueErrors2.Errors = Errors;
    })(ValueErrors = exports.ValueErrors || (exports.ValueErrors = {}));
  }
});

// node_modules/@sinclair/typebox/errors/index.js
var require_errors2 = __commonJS({
  "node_modules/@sinclair/typebox/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
  }
});

// node_modules/@sinclair/typebox/compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/@sinclair/typebox/compiler/compiler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeCompiler = exports.TypeCompilerTypeGuardError = exports.TypeCompilerDereferenceError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;
    var Types = require_typebox();
    var index_1 = require_errors2();
    var index_2 = require_system2();
    var hash_1 = require_hash();
    var TypeCheck = class {
      constructor(schema, references, checkFunc, code) {
        this.schema = schema;
        this.references = references;
        this.checkFunc = checkFunc;
        this.code = code;
      }
      /** Returns the generated assertion code used to validate this type. */
      Code() {
        return this.code;
      }
      /** Returns an iterator for each error in this value. */
      Errors(value) {
        return index_1.ValueErrors.Errors(this.schema, this.references, value);
      }
      /** Returns true if the value matches the compiled type. */
      Check(value) {
        return this.checkFunc(value);
      }
    };
    exports.TypeCheck = TypeCheck;
    var Character;
    (function(Character2) {
      function DollarSign(code) {
        return code === 36;
      }
      Character2.DollarSign = DollarSign;
      function IsUnderscore(code) {
        return code === 95;
      }
      Character2.IsUnderscore = IsUnderscore;
      function IsAlpha(code) {
        return code >= 65 && code <= 90 || code >= 97 && code <= 122;
      }
      Character2.IsAlpha = IsAlpha;
      function IsNumeric(code) {
        return code >= 48 && code <= 57;
      }
      Character2.IsNumeric = IsNumeric;
    })(Character || (Character = {}));
    var MemberExpression;
    (function(MemberExpression2) {
      function IsFirstCharacterNumeric(value) {
        if (value.length === 0)
          return false;
        return Character.IsNumeric(value.charCodeAt(0));
      }
      function IsAccessor(value) {
        if (IsFirstCharacterNumeric(value))
          return false;
        for (let i = 0; i < value.length; i++) {
          const code = value.charCodeAt(i);
          const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
          if (!check)
            return false;
        }
        return true;
      }
      function EscapeHyphen(key) {
        return key.replace(/'/g, "\\'");
      }
      function Encode(object, key) {
        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
      }
      MemberExpression2.Encode = Encode;
    })(MemberExpression || (MemberExpression = {}));
    var Identifier;
    (function(Identifier2) {
      function Encode($id) {
        const buffer = [];
        for (let i = 0; i < $id.length; i++) {
          const code = $id.charCodeAt(i);
          if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
            buffer.push($id.charAt(i));
          } else {
            buffer.push(`_${code}_`);
          }
        }
        return buffer.join("").replace(/__/g, "_");
      }
      Identifier2.Encode = Encode;
    })(Identifier || (Identifier = {}));
    var TypeCompilerUnknownTypeError = class extends Error {
      constructor(schema) {
        super("TypeCompiler: Unknown type");
        this.schema = schema;
      }
    };
    exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
    var TypeCompilerDereferenceError = class extends Error {
      constructor(schema) {
        super(`TypeCompiler: Unable to dereference schema with $id '${schema.$ref}'`);
        this.schema = schema;
      }
    };
    exports.TypeCompilerDereferenceError = TypeCompilerDereferenceError;
    var TypeCompilerTypeGuardError = class extends Error {
      constructor(schema) {
        super("TypeCompiler: Preflight validation check failed to guard for the given schema");
        this.schema = schema;
      }
    };
    exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
    var TypeCompiler;
    (function(TypeCompiler2) {
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      function IsNumber(value) {
        return typeof value === "number" && globalThis.Number.isFinite(value);
      }
      function IsString(value) {
        return typeof value === "string";
      }
      function IsExactOptionalProperty(value, key, expression) {
        return index_2.TypeSystem.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
      }
      function IsObjectCheck(value) {
        return !index_2.TypeSystem.AllowArrayObjects ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
      }
      function IsRecordCheck(value) {
        return !index_2.TypeSystem.AllowArrayObjects ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
      }
      function IsNumberCheck(value) {
        return !index_2.TypeSystem.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;
      }
      function IsVoidCheck(value) {
        return index_2.TypeSystem.AllowVoidNull ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
      }
      function* Any(schema, references, value) {
        yield "true";
      }
      function* Array(schema, references, value) {
        const expression = CreateExpression(schema.items, references, "value");
        yield `Array.isArray(${value}) && ${value}.every(value => ${expression})`;
        if (IsNumber(schema.minItems))
          yield `${value}.length >= ${schema.minItems}`;
        if (IsNumber(schema.maxItems))
          yield `${value}.length <= ${schema.maxItems}`;
        if (schema.uniqueItems === true)
          yield `((function() { const set = new Set(); for(const element of ${value}) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true })())`;
      }
      function* BigInt(schema, references, value) {
        yield `(typeof ${value} === 'bigint')`;
        if (IsBigInt(schema.multipleOf))
          yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
        if (IsBigInt(schema.exclusiveMinimum))
          yield `${value} > BigInt(${schema.exclusiveMinimum})`;
        if (IsBigInt(schema.exclusiveMaximum))
          yield `${value} < BigInt(${schema.exclusiveMaximum})`;
        if (IsBigInt(schema.minimum))
          yield `${value} >= BigInt(${schema.minimum})`;
        if (IsBigInt(schema.maximum))
          yield `${value} <= BigInt(${schema.maximum})`;
      }
      function* Boolean(schema, references, value) {
        yield `typeof ${value} === 'boolean'`;
      }
      function* Constructor(schema, references, value) {
        yield* Visit(schema.returns, references, `${value}.prototype`);
      }
      function* Date(schema, references, value) {
        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
        if (IsNumber(schema.exclusiveMinimumTimestamp))
          yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
        if (IsNumber(schema.exclusiveMaximumTimestamp))
          yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
        if (IsNumber(schema.minimumTimestamp))
          yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
        if (IsNumber(schema.maximumTimestamp))
          yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
      }
      function* Function(schema, references, value) {
        yield `typeof ${value} === 'function'`;
      }
      function* Integer(schema, references, value) {
        yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;
        if (IsNumber(schema.multipleOf))
          yield `(${value} % ${schema.multipleOf}) === 0`;
        if (IsNumber(schema.exclusiveMinimum))
          yield `${value} > ${schema.exclusiveMinimum}`;
        if (IsNumber(schema.exclusiveMaximum))
          yield `${value} < ${schema.exclusiveMaximum}`;
        if (IsNumber(schema.minimum))
          yield `${value} >= ${schema.minimum}`;
        if (IsNumber(schema.maximum))
          yield `${value} <= ${schema.maximum}`;
      }
      function* Intersect(schema, references, value) {
        if (schema.unevaluatedProperties === void 0) {
          const expressions = schema.allOf.map((schema2) => CreateExpression(schema2, references, value));
          yield `${expressions.join(" && ")}`;
        } else if (schema.unevaluatedProperties === false) {
          const schemaKeys = Types.KeyResolver.Resolve(schema).map((key) => `'${key}'`).join(", ");
          const expressions = schema.allOf.map((schema2) => CreateExpression(schema2, references, value));
          const expression1 = `Object.getOwnPropertyNames(${value}).every(key => [${schemaKeys}].includes(key))`;
          yield `${expressions.join(" && ")} && ${expression1}`;
        } else if (typeof schema.unevaluatedProperties === "object") {
          const schemaKeys = Types.KeyResolver.Resolve(schema).map((key) => `'${key}'`).join(", ");
          const expressions = schema.allOf.map((schema2) => CreateExpression(schema2, references, value));
          const expression1 = CreateExpression(schema.unevaluatedProperties, references, "value[key]");
          const expression2 = `Object.getOwnPropertyNames(${value}).every(key => [${schemaKeys}].includes(key) || ${expression1})`;
          yield `${expressions.join(" && ")} && ${expression2}`;
        }
      }
      function* Literal(schema, references, value) {
        if (typeof schema.const === "number" || typeof schema.const === "boolean") {
          yield `${value} === ${schema.const}`;
        } else {
          yield `${value} === '${schema.const}'`;
        }
      }
      function* Never(schema, references, value) {
        yield `false`;
      }
      function* Not(schema, references, value) {
        const left = CreateExpression(schema.allOf[0].not, references, value);
        const right = CreateExpression(schema.allOf[1], references, value);
        yield `!${left} && ${right}`;
      }
      function* Null(schema, references, value) {
        yield `${value} === null`;
      }
      function* Number(schema, references, value) {
        yield IsNumberCheck(value);
        if (IsNumber(schema.multipleOf))
          yield `(${value} % ${schema.multipleOf}) === 0`;
        if (IsNumber(schema.exclusiveMinimum))
          yield `${value} > ${schema.exclusiveMinimum}`;
        if (IsNumber(schema.exclusiveMaximum))
          yield `${value} < ${schema.exclusiveMaximum}`;
        if (IsNumber(schema.minimum))
          yield `${value} >= ${schema.minimum}`;
        if (IsNumber(schema.maximum))
          yield `${value} <= ${schema.maximum}`;
      }
      function* Object2(schema, references, value) {
        yield IsObjectCheck(value);
        if (IsNumber(schema.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
        if (IsNumber(schema.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
        const knownKeys = globalThis.Object.getOwnPropertyNames(schema.properties);
        for (const knownKey of knownKeys) {
          const memberExpression = MemberExpression.Encode(value, knownKey);
          const property = schema.properties[knownKey];
          if (schema.required && schema.required.includes(knownKey)) {
            yield* Visit(property, references, memberExpression);
            if (Types.ExtendsUndefined.Check(property))
              yield `('${knownKey}' in ${value})`;
          } else {
            const expression = CreateExpression(property, references, memberExpression);
            yield IsExactOptionalProperty(value, knownKey, expression);
          }
        }
        if (schema.additionalProperties === false) {
          if (schema.required && schema.required.length === knownKeys.length) {
            yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
          } else {
            const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
            yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
          }
        }
        if (typeof schema.additionalProperties === "object") {
          const expression = CreateExpression(schema.additionalProperties, references, "value[key]");
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
        }
      }
      function* Promise2(schema, references, value) {
        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
      }
      function* Record(schema, references, value) {
        yield IsRecordCheck(value);
        if (IsNumber(schema.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
        if (IsNumber(schema.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
        const [keyPattern, valueSchema] = globalThis.Object.entries(schema.patternProperties)[0];
        const local = PushLocal(`new RegExp(/${keyPattern}/)`);
        yield `(Object.getOwnPropertyNames(${value}).every(key => ${local}.test(key)))`;
        const expression = CreateExpression(valueSchema, references, "value");
        yield `Object.values(${value}).every(value => ${expression})`;
      }
      function* Ref(schema, references, value) {
        const index = references.findIndex((foreign) => foreign.$id === schema.$ref);
        if (index === -1)
          throw new TypeCompilerDereferenceError(schema);
        const target = references[index];
        if (state_local_function_names.has(schema.$ref))
          return yield `${CreateFunctionName(schema.$ref)}(${value})`;
        yield* Visit(target, references, value);
      }
      function* String(schema, references, value) {
        yield `(typeof ${value} === 'string')`;
        if (IsNumber(schema.minLength))
          yield `${value}.length >= ${schema.minLength}`;
        if (IsNumber(schema.maxLength))
          yield `${value}.length <= ${schema.maxLength}`;
        if (schema.pattern !== void 0) {
          const local = PushLocal(`${new RegExp(schema.pattern)};`);
          yield `${local}.test(${value})`;
        }
        if (schema.format !== void 0) {
          yield `format('${schema.format}', ${value})`;
        }
      }
      function* Symbol2(schema, references, value) {
        yield `(typeof ${value} === 'symbol')`;
      }
      function* TemplateLiteral(schema, references, value) {
        yield `(typeof ${value} === 'string')`;
        const local = PushLocal(`${new RegExp(schema.pattern)};`);
        yield `${local}.test(${value})`;
      }
      function* This(schema, references, value) {
        const func = CreateFunctionName(schema.$ref);
        yield `${func}(${value})`;
      }
      function* Tuple(schema, references, value) {
        yield `(Array.isArray(${value}))`;
        if (schema.items === void 0)
          return yield `${value}.length === 0`;
        yield `(${value}.length === ${schema.maxItems})`;
        for (let i = 0; i < schema.items.length; i++) {
          const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
          yield `${expression}`;
        }
      }
      function* Undefined(schema, references, value) {
        yield `${value} === undefined`;
      }
      function* Union(schema, references, value) {
        const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
        yield `(${expressions.join(" || ")})`;
      }
      function* Uint8Array(schema, references, value) {
        yield `${value} instanceof Uint8Array`;
        if (IsNumber(schema.maxByteLength))
          yield `(${value}.length <= ${schema.maxByteLength})`;
        if (IsNumber(schema.minByteLength))
          yield `(${value}.length >= ${schema.minByteLength})`;
      }
      function* Unknown(schema, references, value) {
        yield "true";
      }
      function* Void(schema, references, value) {
        yield IsVoidCheck(value);
      }
      function* UserDefined(schema, references, value) {
        const schema_key = `schema_key_${state_remote_custom_types.size}`;
        state_remote_custom_types.set(schema_key, schema);
        yield `custom('${schema[Types.Kind]}', '${schema_key}', ${value})`;
      }
      function* Visit(schema, references, value) {
        const references_ = IsString(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        if (IsString(schema.$id) && !state_local_function_names.has(schema.$id)) {
          state_local_function_names.add(schema.$id);
          const name = CreateFunctionName(schema.$id);
          const body = CreateFunction(name, schema, references, "value");
          PushFunction(body);
          yield `${name}(${value})`;
          return;
        }
        switch (schema_[Types.Kind]) {
          case "Any":
            return yield* Any(schema_, references_, value);
          case "Array":
            return yield* Array(schema_, references_, value);
          case "BigInt":
            return yield* BigInt(schema_, references_, value);
          case "Boolean":
            return yield* Boolean(schema_, references_, value);
          case "Constructor":
            return yield* Constructor(schema_, references_, value);
          case "Date":
            return yield* Date(schema_, references_, value);
          case "Function":
            return yield* Function(schema_, references_, value);
          case "Integer":
            return yield* Integer(schema_, references_, value);
          case "Intersect":
            return yield* Intersect(schema_, references_, value);
          case "Literal":
            return yield* Literal(schema_, references_, value);
          case "Never":
            return yield* Never(schema_, references_, value);
          case "Not":
            return yield* Not(schema_, references_, value);
          case "Null":
            return yield* Null(schema_, references_, value);
          case "Number":
            return yield* Number(schema_, references_, value);
          case "Object":
            return yield* Object2(schema_, references_, value);
          case "Promise":
            return yield* Promise2(schema_, references_, value);
          case "Record":
            return yield* Record(schema_, references_, value);
          case "Ref":
            return yield* Ref(schema_, references_, value);
          case "String":
            return yield* String(schema_, references_, value);
          case "Symbol":
            return yield* Symbol2(schema_, references_, value);
          case "TemplateLiteral":
            return yield* TemplateLiteral(schema_, references_, value);
          case "This":
            return yield* This(schema_, references_, value);
          case "Tuple":
            return yield* Tuple(schema_, references_, value);
          case "Undefined":
            return yield* Undefined(schema_, references_, value);
          case "Union":
            return yield* Union(schema_, references_, value);
          case "Uint8Array":
            return yield* Uint8Array(schema_, references_, value);
          case "Unknown":
            return yield* Unknown(schema_, references_, value);
          case "Void":
            return yield* Void(schema_, references_, value);
          default:
            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
              throw new TypeCompilerUnknownTypeError(schema);
            return yield* UserDefined(schema_, references_, value);
        }
      }
      const state_local_variables = /* @__PURE__ */ new Set();
      const state_local_function_names = /* @__PURE__ */ new Set();
      const state_remote_custom_types = /* @__PURE__ */ new Map();
      function ResetCompiler() {
        state_local_variables.clear();
        state_local_function_names.clear();
        state_remote_custom_types.clear();
      }
      function CreateExpression(schema, references, value) {
        return `(${[...Visit(schema, references, value)].join(" && ")})`;
      }
      function CreateFunctionName($id) {
        return `check_${Identifier.Encode($id)}`;
      }
      function CreateFunction(name, schema, references, value) {
        const expression = [...Visit(schema, references, value)].map((condition) => `    ${condition}`).join(" &&\n");
        return `function ${name}(value) {
  return (
${expression}
 )
}`;
      }
      function PushFunction(functionBody) {
        state_local_variables.add(functionBody);
      }
      function PushLocal(expression) {
        const local = `local_${state_local_variables.size}`;
        state_local_variables.add(`const ${local} = ${expression}`);
        return local;
      }
      function GetLocals() {
        return [...state_local_variables.values()];
      }
      function Build(schema, references) {
        ResetCompiler();
        const check = CreateFunction("check", schema, references, "value");
        const locals = GetLocals();
        return `${locals.join("\n")}
return ${check}`;
      }
      function Code(schema, references = []) {
        if (!Types.TypeGuard.TSchema(schema))
          throw new TypeCompilerTypeGuardError(schema);
        for (const schema2 of references)
          if (!Types.TypeGuard.TSchema(schema2))
            throw new TypeCompilerTypeGuardError(schema2);
        return Build(schema, references);
      }
      TypeCompiler2.Code = Code;
      function Compile(schema, references = []) {
        const code = Code(schema, references);
        const custom_schemas = new Map(state_remote_custom_types);
        const compiledFunction = globalThis.Function("custom", "format", "hash", code);
        const checkFunction = compiledFunction((kind, schema_key, value) => {
          if (!Types.TypeRegistry.Has(kind) || !custom_schemas.has(schema_key))
            return false;
          const schema2 = custom_schemas.get(schema_key);
          const func = Types.TypeRegistry.Get(kind);
          return func(schema2, value);
        }, (format, value) => {
          if (!Types.FormatRegistry.Has(format))
            return false;
          const func = Types.FormatRegistry.Get(format);
          return func(value);
        }, (value) => {
          return hash_1.ValueHash.Create(value);
        });
        return new TypeCheck(schema, references, checkFunction, code);
      }
      TypeCompiler2.Compile = Compile;
    })(TypeCompiler = exports.TypeCompiler || (exports.TypeCompiler = {}));
  }
});

// node_modules/@sinclair/typebox/compiler/index.js
var require_compiler2 = __commonJS({
  "node_modules/@sinclair/typebox/compiler/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrorType = void 0;
    var index_1 = require_errors2();
    Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
      return index_1.ValueErrorType;
    } });
    __exportStar(require_compiler(), exports);
  }
});
export default require_compiler2();
//# sourceMappingURL=@sinclair_typebox_compiler.js.map
