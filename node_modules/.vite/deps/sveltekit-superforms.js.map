{
  "version": 3,
  "sources": ["../../sveltekit-superforms/dist/client/SuperDebug.svelte", "../../sveltekit-superforms/dist/client/superForm.js", "../../sveltekit-superforms/dist/client/flash.js", "../../sveltekit-superforms/dist/client/customValidity.js", "../../sveltekit-superforms/dist/client/elements.js", "../../sveltekit-superforms/dist/client/form.js", "../../sveltekit-superforms/dist/client/proxies.js", "../../sveltekit-superforms/dist/defaults.js", "../../sveltekit-superforms/dist/actionResult.js", "../../sveltekit-superforms/dist/superValidate.js", "../../sveltekit-superforms/dist/formData.js", "../../sveltekit-superforms/dist/index.js"],
  "sourcesContent": [null, "import { derived, get, readonly, writable } from 'svelte/store';\nimport { navigating, page } from '$app/stores';\nimport { clone } from '../utils.js';\nimport { browser } from '$app/environment';\nimport { onDestroy, tick } from 'svelte';\nimport { comparePaths, pathExists, setPaths, traversePath, traversePaths } from '../traversal.js';\nimport { splitPath, mergePath } from '../stringPath.js';\nimport { beforeNavigate, goto, invalidateAll } from '$app/navigation';\nimport { SuperFormError, flattenErrors, mapErrors, updateErrors } from '../errors.js';\nimport { cancelFlash, shouldSyncFlash } from './flash.js';\nimport { applyAction, enhance } from '$app/forms';\nimport { setCustomValidityForm, updateCustomValidity } from './customValidity.js';\nimport { inputInfo } from './elements.js';\nimport { Form as HtmlForm, scrollToFirstError } from './form.js';\nimport { stringify } from 'devalue';\nimport { fieldProxy } from './proxies.js';\nconst formIds = new WeakMap();\nconst initialForms = new WeakMap();\nconst defaultOnError = (event) => {\n    console.warn('Unhandled Superform error, use onError event to handle it:', event.result.error);\n};\nconst defaultFormOptions = {\n    applyAction: true,\n    invalidateAll: true,\n    resetForm: true,\n    autoFocusOnError: 'detect',\n    scrollToError: 'smooth',\n    errorSelector: '[aria-invalid=\"true\"],[data-invalid]',\n    selectErrorText: false,\n    stickyNavbar: undefined,\n    taintedMessage: false,\n    onSubmit: undefined,\n    onResult: undefined,\n    onUpdate: undefined,\n    onUpdated: undefined,\n    onError: defaultOnError,\n    dataType: 'form',\n    validators: undefined,\n    customValidity: false,\n    clearOnSubmit: 'errors-and-message',\n    delayMs: 500,\n    timeoutMs: 8000,\n    multipleSubmits: 'prevent',\n    SPA: undefined,\n    validationMethod: 'auto'\n};\nfunction multipleFormIdError(id) {\n    return (`Duplicate form id's found: \"${id}\". ` +\n        'Multiple forms will receive the same data. Use the id option to differentiate between them, ' +\n        'or if this is intended, set the warnings.duplicateId option to false in superForm to disable this warning. ' +\n        'More information: https://superforms.rocks/concepts/multiple-forms');\n}\n/**\n * V1 compatibilty. resetForm = false and taintedMessage = true\n */\nlet legacyMode = false;\ntry {\n    // @ts-expect-error Vite define check\n    if (SUPERFORMS_LEGACY)\n        legacyMode = true;\n}\ncatch {\n    // No legacy mode defined\n}\n/**\n * Initializes a SvelteKit form, for convenient handling of values, errors and sumbitting data.\n * @param {SuperValidated} form Usually data.form from PageData.\n * @param {FormOptions} options Configuration for the form.\n * @returns {SuperForm} An object with properties for the form.\n * @DCI-context\n */\nexport function superForm(form, formOptions) {\n    // Used in reset\n    let initialForm;\n    let options = formOptions ?? {};\n    // To check if a full validator is used when switching options.validators dynamically\n    let initialValidator = undefined;\n    {\n        if (options.legacy ?? legacyMode) {\n            if (options.resetForm === undefined)\n                options.resetForm = false;\n            if (options.taintedMessage === undefined)\n                options.taintedMessage = true;\n        }\n        initialValidator = options.validators;\n        options = {\n            ...defaultFormOptions,\n            ...options\n        };\n        if (options.SPA && options.validators === undefined) {\n            console.warn('No validators set for superForm in SPA mode. ' +\n                'Add a validation adapter to the validators option, or set it to false to disable this warning.');\n        }\n        if (!form) {\n            throw new SuperFormError('No form data sent to superForm. ' +\n                \"Make sure the output from superValidate is used (usually data.form) and that it's not null or undefined. \" +\n                \"Alternatively, an object with default values for the form can also be used, but then constraints won't be available.\");\n        }\n        if (Context_isValidationObject(form) === false) {\n            form = {\n                id: options.id ?? '',\n                valid: false,\n                posted: false,\n                errors: {},\n                data: form\n            };\n        }\n        form = form;\n        // Check multiple id's\n        const _initialFormId = options.id ?? form.id;\n        const _currentPage = get(page);\n        if (browser && options.warnings?.duplicateId !== false) {\n            if (!formIds.has(_currentPage)) {\n                formIds.set(_currentPage, new Set([_initialFormId]));\n            }\n            else {\n                const currentForms = formIds.get(_currentPage);\n                if (currentForms?.has(_initialFormId)) {\n                    console.warn(multipleFormIdError(_initialFormId));\n                }\n                else {\n                    currentForms?.add(_initialFormId);\n                }\n            }\n        }\n        /**\n         * Need to clone the form data, in case it's used to populate multiple forms\n         * and in components that are mounted and destroyed multiple times.\n         * This also means that it needs to be set here, before it's cloned further below.\n         */\n        if (!initialForms.has(form)) {\n            initialForms.set(form, form);\n        }\n        initialForm = initialForms.get(form);\n        if (typeof initialForm.valid !== 'boolean') {\n            throw new SuperFormError('A non-validation object was passed to superForm. ' +\n                'It should be an object of type SuperValidated, usually returned from superValidate.');\n        }\n        // Detect if a form is posted without JavaScript.\n        if (!browser && _currentPage.form && typeof _currentPage.form === 'object') {\n            const postedData = _currentPage.form;\n            for (const postedForm of Context_findValidationForms(postedData).reverse()) {\n                if (postedForm.id == _initialFormId && !initialForms.has(postedForm)) {\n                    // Prevent multiple \"posting\" that can happen when components are recreated.\n                    initialForms.set(postedData, postedData);\n                    const pageDataForm = form;\n                    // Add the missing fields from the page data form\n                    form = postedForm;\n                    form.constraints = pageDataForm.constraints;\n                    form.shape = pageDataForm.shape;\n                    // Reset the form if option set and form is valid.\n                    if (form.valid &&\n                        options.resetForm &&\n                        (options.resetForm === true || options.resetForm())) {\n                        form = clone(pageDataForm);\n                        form.message = clone(postedForm.message);\n                    }\n                    break;\n                }\n            }\n        }\n        else {\n            form = clone(initialForm);\n        }\n        ///// From here, form is properly initialized /////\n        onDestroy(() => {\n            Unsubscriptions_unsubscribe();\n            NextChange_clear();\n            for (const events of Object.values(formEvents)) {\n                events.length = 0;\n            }\n            formIds.get(_currentPage)?.delete(_initialFormId);\n        });\n        // Check for nested objects, throw if datatype isn't json\n        if (options.dataType !== 'json') {\n            const checkForNestedData = (key, value) => {\n                if (!value || typeof value !== 'object')\n                    return;\n                if (Array.isArray(value)) {\n                    if (value.length > 0)\n                        checkForNestedData(key, value[0]);\n                }\n                else if (!(value instanceof Date) &&\n                    !(value instanceof File) &&\n                    (!browser || !(value instanceof FileList))) {\n                    throw new SuperFormError(`Object found in form field \"${key}\". ` +\n                        `Set the dataType option to \"json\" and add use:enhance to use nested data structures. ` +\n                        `More information: https://superforms.rocks/concepts/nested-data`);\n                }\n            };\n            for (const [key, value] of Object.entries(form.data)) {\n                checkForNestedData(key, value);\n            }\n        }\n    }\n    ///// Roles ///////////////////////////////////////////////////////\n    //#region Data\n    /**\n     * Container for store data, subscribed to with Unsubscriptions\n     * to avoid \"get\" usage.\n     */\n    const __data = {\n        formId: form.id,\n        form: clone(form.data),\n        constraints: form.constraints ?? {},\n        posted: form.posted,\n        errors: clone(form.errors),\n        message: clone(form.message),\n        tainted: undefined,\n        valid: form.valid,\n        submitting: false,\n        shape: form.shape\n    };\n    const Data = __data;\n    //#endregion\n    //#region FormId\n    const FormId = writable(options.id ?? form.id);\n    //#endregion\n    //#region Context\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const Context = {};\n    function Context_findValidationForms(data) {\n        const forms = Object.values(data).filter((v) => Context_isValidationObject(v) !== false);\n        return forms;\n    }\n    /**\n     * Return false if object isn't a validation object, otherwise the form id,\n     * which can be an empty string, so always check with === false\n     */\n    function Context_isValidationObject(object) {\n        if (!object || typeof object !== 'object')\n            return false;\n        if (!('valid' in object && 'errors' in object && typeof object.valid === 'boolean')) {\n            return false;\n        }\n        return 'id' in object && typeof object.id === 'string' ? object.id : false;\n    }\n    //#endregion\n    //#region Form\n    // eslint-disable-next-line dci-lint/grouped-rolemethods\n    const _formData = writable(form.data);\n    const Form = {\n        subscribe: _formData.subscribe,\n        set: (value, options = {}) => {\n            // Need to clone the value, so it won't refer to $page for example.\n            const newData = clone(value);\n            Tainted_update(newData, options.taint ?? true);\n            return _formData.set(newData);\n        },\n        update: (updater, options = {}) => {\n            return _formData.update((value) => {\n                // No cloning here, since it's an update\n                const newData = updater(value);\n                Tainted_update(newData, options.taint ?? true);\n                return newData;\n            });\n        }\n    };\n    async function Form_validate(opts = {}) {\n        const dataToValidate = opts.formData ?? Data.form;\n        let errors = {};\n        let status;\n        const validator = opts.adapter ?? options.validators;\n        if (typeof validator == 'object') {\n            // Checking for full validation with the jsonSchema field (doesn't exist in client validators).\n            if (validator != initialValidator && !('jsonSchema' in validator)) {\n                throw new SuperFormError('Client validation adapter found in options.validators. ' +\n                    'A full adapter must be used when changing validators dynamically, for example \"zod\" instead of \"zodClient\".');\n            }\n            status = await /* @__PURE__ */ validator.validate(dataToValidate);\n            if (!status.success) {\n                errors = mapErrors(status.issues, validator.shape ?? Data.shape ?? {});\n            }\n            else if (opts.recheckValidData !== false) {\n                // need to make an additional validation, in case the data has been transformed\n                return Form_validate({ ...opts, recheckValidData: false });\n            }\n        }\n        else {\n            status = { success: true, data: {} };\n        }\n        const data = { ...Data.form, ...dataToValidate, ...(status.success ? status.data : {}) };\n        return {\n            valid: status.success,\n            posted: false,\n            errors,\n            data,\n            constraints: Data.constraints,\n            message: undefined,\n            id: Data.formId,\n            shape: Data.shape\n        };\n    }\n    function Form__changeEvent(event) {\n        if (!options.onChange || !event.paths.length || event.type == 'blur')\n            return;\n        let changeEvent;\n        const paths = event.paths.map(mergePath);\n        if (event.type &&\n            event.paths.length == 1 &&\n            event.formElement &&\n            event.target instanceof Element) {\n            changeEvent = {\n                path: paths[0],\n                paths,\n                formElement: event.formElement,\n                target: event.target,\n                set(path, value, options) {\n                    // Casting trick to make it think it's a SuperForm\n                    fieldProxy({ form: Form }, path, options).set(value);\n                },\n                get(path) {\n                    return get(fieldProxy(Form, path));\n                }\n            };\n        }\n        else {\n            changeEvent = {\n                paths,\n                target: undefined,\n                set(path, value, options) {\n                    // Casting trick to make it think it's a SuperForm\n                    fieldProxy({ form: Form }, path, options).set(value);\n                },\n                get(path) {\n                    return get(fieldProxy(Form, path));\n                }\n            };\n        }\n        options.onChange(changeEvent);\n    }\n    /**\n     * Make a client-side validation, updating the form data if successful.\n     * @param event A change event, from html input or programmatically\n     * @param force Is true if called from validateForm with update: true\n     * @param adapter ValidationAdapter, if called from validateForm with schema set\n     * @returns SuperValidated, or undefined if options prevented validation.\n     */\n    async function Form_clientValidation(event, force = false, adapter) {\n        if (event) {\n            if (options.validators == 'clear') {\n                Errors.update(($errors) => {\n                    setPaths($errors, event.paths, undefined);\n                    return $errors;\n                });\n            }\n            setTimeout(() => Form__changeEvent(event));\n        }\n        if (!event || !options.validators || options.validators == 'clear')\n            return;\n        if (!force) {\n            if (options.validationMethod == 'onsubmit' || options.validationMethod == 'submit-only') {\n                return;\n            }\n            if (options.validationMethod == 'onblur' && event.type == 'input')\n                return;\n            if (options.validationMethod == 'oninput' && event.type == 'blur')\n                return;\n        }\n        const result = await Form_validate({ adapter });\n        // TODO: Add option for always setting result.data?\n        if (result.valid && (event.immediate || event.type != 'input')) {\n            Form.set(result.data, { taint: 'ignore' });\n        }\n        // Wait for tainted, so object errors can be displayed\n        await tick();\n        Form__displayNewErrors(result.errors, event, force);\n        return result;\n    }\n    async function Form__displayNewErrors(errors, event, force) {\n        const { type, immediate, multiple, paths } = event;\n        const previous = Data.errors;\n        const output = {};\n        const validity = new Map();\n        const formElement = event.formElement ?? EnhancedForm;\n        if (options.customValidity && formElement) {\n            for (const path of event.paths) {\n                const name = CSS.escape(mergePath(path));\n                const el = formElement.querySelector(`[name=\"${name}\"]`);\n                if (el) {\n                    const message = 'validationMessage' in el ? String(el.validationMessage) : '';\n                    validity.set(path.join(), { el, message });\n                    updateCustomValidity(el, undefined);\n                }\n            }\n        }\n        traversePaths(errors, (error) => {\n            if (!Array.isArray(error.value))\n                return;\n            let joinedPath = error.path.join('.');\n            if (joinedPath.endsWith('._errors')) {\n                joinedPath = joinedPath.substring(0, -8);\n            }\n            function addError() {\n                //console.log('Adding error', `[${error.path.join('.')}]`, error.value); //debug\n                setPaths(output, [error.path], error.value);\n                if (options.customValidity && isEventError && validity.has(joinedPath)) {\n                    const { el, message } = validity.get(joinedPath);\n                    if (message != error.value) {\n                        updateCustomValidity(el, error.value);\n                        // Only need one error to display\n                        validity.clear();\n                    }\n                }\n            }\n            if (force)\n                return addError();\n            const isEventError = error.value &&\n                paths.map((path) => path.join('.')).some((path) => path.startsWith(joinedPath));\n            if (isEventError && options.validationMethod == 'oninput')\n                return addError();\n            // Immediate, non-multiple input should display the errors\n            if (immediate && !multiple && isEventError)\n                return addError();\n            // Special case for multiple, which should display errors on blur\n            // or if any error has existed previously. Tricky UX.\n            if (multiple) {\n                // For multi-select, if any error has existed, display all errors\n                const errorPath = pathExists(get(Errors), error.path.slice(0, -1));\n                if (errorPath?.value && typeof errorPath?.value == 'object') {\n                    for (const errors of Object.values(errorPath.value)) {\n                        if (Array.isArray(errors)) {\n                            return addError();\n                        }\n                    }\n                }\n            }\n            // If previous error exist, always display\n            const previousError = pathExists(previous, error.path);\n            if (previousError && previousError.key in previousError.parent) {\n                return addError();\n            }\n            const lastPath = error.path[error.path.length - 1];\n            const isObjectError = lastPath == '_errors';\n            //const isErrorInArray = error.path.some((p) => /^\\d+$/.test(String(p)));\n            if (isObjectError) {\n                // New object errors should be displayed on blur events,\n                // or the (parent) path is or has been tainted.\n                if (options.validationMethod == 'oninput' ||\n                    (type == 'blur' &&\n                        Tainted_hasBeenTainted(mergePath(error.path.slice(0, -1))))) {\n                    return addError();\n                }\n            }\n            else {\n                // Display text errors on blur, if the event matches the error path\n                // Also, display errors if the error is in an array an it has been tainted.\n                if (type == 'blur' &&\n                    isEventError\n                //|| (isErrorInArray &&\tTainted_hasBeenTainted(mergePath(error.path.slice(0, -1)) as FormPath<T>))\n                ) {\n                    return addError();\n                }\n            }\n        });\n        Errors.set(output);\n    }\n    function Form_set(data, options = {}) {\n        // Check if file fields should be kept, usually when the server returns them as undefined.\n        // in that case remove the undefined field from the new data.\n        if (options.keepFiles) {\n            traversePaths(Data.form, (info) => {\n                if ((!browser || !(info.parent instanceof FileList)) &&\n                    (info.value instanceof File || (browser && info.value instanceof FileList))) {\n                    const dataPath = pathExists(data, info.path);\n                    if (!dataPath || !(dataPath.key in dataPath.parent)) {\n                        setPaths(data, [info.path], info.value);\n                    }\n                }\n            });\n        }\n        return Form.set(data, options);\n    }\n    function Form_shouldReset(validForm, successActionResult) {\n        return (validForm &&\n            successActionResult &&\n            options.resetForm &&\n            (options.resetForm === true || options.resetForm()));\n    }\n    async function Form_updateFromValidation(form, successResult) {\n        if (form.valid && successResult && Form_shouldReset(form.valid, successResult)) {\n            Form_reset({ message: form.message, posted: true });\n        }\n        else {\n            rebind({\n                form,\n                untaint: successResult,\n                keepFiles: true,\n                // Check if the form data should be used for updating, or if the invalidateAll load function should be used:\n                skipFormData: options.invalidateAll == 'force'\n            });\n        }\n        // onUpdated may check stores, so need to wait for them to update.\n        if (formEvents.onUpdated.length) {\n            await tick();\n        }\n        // But do not await on onUpdated itself, since we're already finished with the request\n        for (const event of formEvents.onUpdated) {\n            event({ form });\n        }\n    }\n    function Form_reset(opts = {}) {\n        if (opts.newState)\n            initialForm.data = { ...initialForm.data, ...opts.newState };\n        const resetData = clone(initialForm);\n        resetData.data = { ...resetData.data, ...opts.data };\n        if (opts.id !== undefined)\n            resetData.id = opts.id;\n        rebind({\n            form: resetData,\n            untaint: true,\n            message: opts.message,\n            keepFiles: false,\n            posted: opts.posted\n        });\n    }\n    async function Form_updateFromActionResult(result) {\n        if (result.type == 'error') {\n            throw new SuperFormError(`ActionResult of type \"${result.type}\" cannot be passed to update function.`);\n        }\n        if (result.type == 'redirect') {\n            // All we need to do if redirected is to reset the form.\n            // No events should be triggered because technically we're somewhere else.\n            if (Form_shouldReset(true, true))\n                Form_reset({ posted: true });\n            return;\n        }\n        if (typeof result.data !== 'object') {\n            throw new SuperFormError('Non-object validation data returned from ActionResult.');\n        }\n        const forms = Context_findValidationForms(result.data);\n        if (!forms.length) {\n            throw new SuperFormError('No form data returned from ActionResult. Make sure you return { form } in the form actions.');\n        }\n        for (const newForm of forms) {\n            if (newForm.id !== Data.formId)\n                continue;\n            await Form_updateFromValidation(newForm, result.status >= 200 && result.status < 300);\n        }\n    }\n    //#endregion\n    const Message = writable(__data.message);\n    const Constraints = writable(__data.constraints);\n    const Posted = writable(__data.posted);\n    const Shape = writable(__data.shape);\n    //#region Errors\n    const _errors = writable(form.errors);\n    // eslint-disable-next-line dci-lint/grouped-rolemethods\n    const Errors = {\n        subscribe: _errors.subscribe,\n        set(value, options) {\n            return _errors.set(updateErrors(value, Data.errors, options?.force));\n        },\n        update(updater, options) {\n            return _errors.update((value) => {\n                return updateErrors(updater(value), Data.errors, options?.force);\n            });\n        },\n        /**\n         * To work with client-side validation, errors cannot be deleted but must\n         * be set to undefined, to know where they existed before (tainted+error check in oninput)\n         */\n        clear: () => undefined\n    };\n    //#endregion\n    //#region NextChange /////\n    let NextChange = null;\n    function NextChange_setHtmlEvent(event) {\n        NextChange = event;\n        // Wait for on:input to provide additional information\n        setTimeout(() => {\n            Form_clientValidation(NextChange);\n        }, 0);\n    }\n    function NextChange_additionalEventInformation(event, immediate, multiple, formElement, target) {\n        if (NextChange === null) {\n            NextChange = { paths: [] };\n        }\n        NextChange.type = event;\n        NextChange.immediate = immediate;\n        NextChange.multiple = multiple;\n        NextChange.formElement = formElement;\n        NextChange.target = target;\n    }\n    function NextChange_paths() {\n        return NextChange?.paths ?? [];\n    }\n    function NextChange_clear() {\n        NextChange = null;\n    }\n    //#endregion\n    //#region Tainted\n    const Tainted = {\n        state: writable(),\n        message: options.taintedMessage,\n        clean: clone(form.data) // Important to clone form.data, so it's not comparing the same object,\n    };\n    function Tainted_enable() {\n        options.taintedMessage = Tainted.message;\n    }\n    function Tainted_currentState() {\n        return Tainted.state;\n    }\n    function Tainted_hasBeenTainted(path) {\n        if (!Data.tainted)\n            return false;\n        if (!path)\n            return !!Data.tainted;\n        const field = pathExists(Data.tainted, splitPath(path));\n        return !!field && field.key in field.parent;\n    }\n    function Tainted_isTainted(path) {\n        if (typeof path === 'boolean')\n            return path;\n        if (typeof path === 'object')\n            return Tainted__isObjectTainted(path);\n        if (!Data.tainted)\n            return false;\n        if (!path)\n            return Tainted__isObjectTainted(Data.tainted);\n        const field = pathExists(Data.tainted, splitPath(path));\n        return Tainted__isObjectTainted(field?.value);\n    }\n    function Tainted__isObjectTainted(obj) {\n        if (!obj)\n            return false;\n        if (typeof obj === 'object') {\n            for (const obj2 of Object.values(obj)) {\n                if (Tainted__isObjectTainted(obj2))\n                    return true;\n            }\n        }\n        return obj === true;\n    }\n    /**\n     * Updates the tainted state. Use most of the time, except when submitting.\n     */\n    function Tainted_update(newData, taintOptions) {\n        // Ignore is set when returning errors from the server\n        // so status messages and form-level errors won't be\n        // immediately cleared by client-side validation.\n        if (taintOptions == 'ignore')\n            return;\n        const paths = comparePaths(newData, Data.form);\n        if (paths.length) {\n            if (taintOptions == 'untaint-all' || taintOptions == 'untaint-form') {\n                Tainted.state.set(undefined);\n            }\n            else {\n                Tainted.state.update((tainted) => {\n                    if (!tainted)\n                        tainted = {};\n                    setPaths(tainted, paths, (path, data) => {\n                        // If value goes back to the clean value, untaint the path\n                        const currentValue = traversePath(newData, path);\n                        const cleanPath = traversePath(Tainted.clean, path);\n                        return currentValue && cleanPath && currentValue.value === cleanPath.value\n                            ? undefined\n                            : taintOptions === true\n                                ? true\n                                : taintOptions === 'untaint'\n                                    ? undefined\n                                    : data.value;\n                    });\n                    return tainted;\n                });\n            }\n        }\n        NextChange_setHtmlEvent({ paths });\n    }\n    /**\n     * Overwrites the current tainted state and setting a new clean state for the form data.\n     * @param tainted\n     * @param newClean\n     */\n    function Tainted_set(tainted, newClean) {\n        // TODO: Is it better to set tainted values to undefined instead of just overwriting?\n        Tainted.state.set(tainted);\n        if (newClean)\n            Tainted.clean = newClean;\n    }\n    //#endregion\n    //#region Timers\n    const Submitting = writable(false);\n    const Delayed = writable(false);\n    // eslint-disable-next-line dci-lint/grouped-rolemethods\n    const Timeout = writable(false);\n    //#endregion\n    //#region Unsubscriptions\n    /**\n     * Subscribe to certain stores and store the current value in Data, to avoid using get.\n     * Need to clone the form data, so it won't refer to the same object and prevent change detection\n     */\n    const Unsubscriptions = [\n        // eslint-disable-next-line dci-lint/private-role-access\n        Tainted.state.subscribe((tainted) => (__data.tainted = clone(tainted))),\n        // eslint-disable-next-line dci-lint/private-role-access\n        Form.subscribe((form) => (__data.form = clone(form))),\n        // eslint-disable-next-line dci-lint/private-role-access\n        Errors.subscribe((errors) => (__data.errors = clone(errors))),\n        FormId.subscribe((id) => (__data.formId = id)),\n        Constraints.subscribe((constraints) => (__data.constraints = constraints)),\n        Posted.subscribe((posted) => (__data.posted = posted)),\n        Message.subscribe((message) => (__data.message = message)),\n        Submitting.subscribe((submitting) => (__data.submitting = submitting)),\n        Shape.subscribe((shape) => (__data.shape = shape))\n    ];\n    function Unsubscriptions_add(func) {\n        Unsubscriptions.push(func);\n    }\n    function Unsubscriptions_unsubscribe() {\n        Unsubscriptions.forEach((unsub) => unsub());\n    }\n    //#endregion\n    const AllErrors = derived(Errors, ($errors) => ($errors ? flattenErrors($errors) : []));\n    // Used for options.customValidity to display errors, even if programmatically set\n    let EnhancedForm;\n    ///// End of Roles //////////////////////////////////////////////////////////\n    // Need to clear this and set it again when use:enhance has run, to avoid showing the\n    // tainted dialog when a form doesn't use it or the browser doesn't use JS.\n    options.taintedMessage = undefined;\n    // Role rebinding\n    function rebind(opts) {\n        //console.log('🚀 ~ file: superForm.ts:721 ~ rebind ~ form:', form.data); //debug\n        const form = opts.form;\n        const message = opts.message ?? form.message;\n        if (opts.untaint) {\n            Tainted_set(typeof opts.untaint === 'boolean' ? undefined : opts.untaint, form.data);\n        }\n        // Form data is not tainted when rebinding.\n        // Prevents object errors from being revalidated after rebind.\n        // Check if form was invalidated (usually with options.invalidateAll) to prevent data from being\n        // overwritten by the load function data\n        if (opts.skipFormData !== true) {\n            Form_set(form.data, {\n                taint: 'ignore',\n                keepFiles: opts.keepFiles\n            });\n        }\n        Message.set(message);\n        Errors.set(form.errors);\n        FormId.set(form.id);\n        Posted.set(opts.posted ?? form.posted);\n        // Constraints and shape will only be set when they exist.\n        if (form.constraints)\n            Constraints.set(form.constraints);\n        if (form.shape)\n            Shape.set(form.shape);\n        // Only allowed non-subscribe __data access, here in rebind\n        __data.valid = form.valid;\n        if (options.flashMessage && shouldSyncFlash(options)) {\n            const flash = options.flashMessage.module.getFlash(page);\n            if (message && get(flash) === undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                flash.set(message);\n            }\n        }\n    }\n    const formEvents = {\n        onSubmit: options.onSubmit ? [options.onSubmit] : [],\n        onResult: options.onResult ? [options.onResult] : [],\n        onUpdate: options.onUpdate ? [options.onUpdate] : [],\n        onUpdated: options.onUpdated ? [options.onUpdated] : [],\n        onError: options.onError ? [options.onError] : []\n    };\n    if (browser) {\n        // Tainted check\n        const defaultMessage = 'Leave page? Changes that you made may not be saved.';\n        let forceRedirection = false;\n        beforeNavigate(async (nav) => {\n            if (options.taintedMessage && !Data.submitting && !forceRedirection) {\n                if (Tainted_isTainted()) {\n                    const { taintedMessage } = options;\n                    // As beforeNavigate does not support Promise, we cancel the redirection until the promise resolve\n                    nav.cancel();\n                    // Does not display any dialog on page refresh or closing tab and let the default browser behaviour\n                    if (nav.type === 'leave')\n                        return;\n                    const isTaintedFunction = typeof taintedMessage === 'function';\n                    const message = isTaintedFunction || taintedMessage === true ? defaultMessage : taintedMessage;\n                    // - rejected => shouldRedirect = false\n                    // - resolved with false => shouldRedirect = false\n                    // - resolved with true => shouldRedirect = true\n                    const confirmFunction = isTaintedFunction\n                        ? taintedMessage\n                        : () => window.confirm(message);\n                    let shouldRedirect;\n                    try {\n                        shouldRedirect = await confirmFunction();\n                    }\n                    catch {\n                        shouldRedirect = false;\n                    }\n                    if (shouldRedirect && nav.to) {\n                        try {\n                            forceRedirection = true;\n                            await goto(nav.to.url, { ...nav.to.params });\n                            return;\n                        }\n                        finally {\n                            // Reset forceRedirection for multiple-tainted purpose\n                            forceRedirection = false;\n                        }\n                    }\n                }\n            }\n        });\n        // Need to subscribe to catch page invalidation.\n        Unsubscriptions_add(page.subscribe(async (pageUpdate) => {\n            const successResult = pageUpdate.status >= 200 && pageUpdate.status < 300;\n            if (options.applyAction && pageUpdate.form && typeof pageUpdate.form === 'object') {\n                const actionData = pageUpdate.form;\n                // Check if it is an error result, sent here from formEnhance\n                if (actionData.type == 'error')\n                    return;\n                for (const newForm of Context_findValidationForms(actionData)) {\n                    const isInitial = initialForms.has(newForm);\n                    if (newForm.id !== Data.formId || isInitial) {\n                        continue;\n                    }\n                    // Prevent multiple \"posting\" that can happen when components are recreated.\n                    initialForms.set(newForm, newForm);\n                    await Form_updateFromValidation(newForm, successResult);\n                }\n            }\n            else if (pageUpdate.data && typeof pageUpdate.data === 'object') {\n                // It's a page reload, redirect or error/failure,\n                // so don't trigger any events, just update the data.\n                for (const newForm of Context_findValidationForms(pageUpdate.data)) {\n                    const isInitial = initialForms.has(newForm);\n                    if (newForm.id !== Data.formId || isInitial) {\n                        continue;\n                    }\n                    if (options.invalidateAll === 'force') {\n                        initialForm.data = newForm.data;\n                    }\n                    rebind({\n                        form: newForm,\n                        untaint: successResult,\n                        keepFiles: true\n                    });\n                }\n            }\n        }));\n    }\n    ///// Return the SuperForm object /////////////////////////////////\n    return {\n        form: Form,\n        formId: FormId,\n        errors: Errors,\n        message: Message,\n        constraints: Constraints,\n        tainted: Tainted_currentState(),\n        submitting: readonly(Submitting),\n        delayed: readonly(Delayed),\n        timeout: readonly(Timeout),\n        options: options,\n        capture() {\n            return {\n                valid: Data.valid,\n                posted: Data.posted,\n                errors: Data.errors,\n                data: Data.form,\n                constraints: Data.constraints,\n                message: Data.message,\n                id: Data.formId,\n                tainted: Data.tainted,\n                shape: Data.shape\n            };\n        },\n        restore: ((snapshot) => {\n            rebind({ form: snapshot, untaint: snapshot.tainted ?? true });\n        }),\n        async validate(path, opts = {}) {\n            if (!options.validators) {\n                throw new SuperFormError('options.validators must be set to use the validate method.');\n            }\n            if (opts.update === undefined)\n                opts.update = true;\n            if (opts.taint === undefined)\n                opts.taint = false;\n            if (typeof opts.errors == 'string')\n                opts.errors = [opts.errors];\n            let data;\n            const splittedPath = splitPath(path);\n            if ('value' in opts) {\n                if (opts.update === true || opts.update === 'value') {\n                    // eslint-disable-next-line dci-lint/private-role-access\n                    Form.update(($form) => {\n                        setPaths($form, [splittedPath], opts.value);\n                        return $form;\n                    }, { taint: opts.taint });\n                    data = Data.form;\n                }\n                else {\n                    data = clone(Data.form);\n                    setPaths(data, [splittedPath], opts.value);\n                }\n            }\n            else {\n                data = Data.form;\n            }\n            const result = await Form_validate({ formData: data });\n            const error = pathExists(result.errors, splittedPath);\n            // Replace with custom error, if it exist\n            if (error && error.value && opts.errors) {\n                error.value = opts.errors;\n            }\n            if (opts.update === true || opts.update == 'errors') {\n                Errors.update(($errors) => {\n                    setPaths($errors, [splittedPath], error?.value);\n                    return $errors;\n                });\n            }\n            return error?.value;\n        },\n        async validateForm(opts = {}) {\n            if (!options.validators && !opts.schema) {\n                throw new SuperFormError('options.validators or the schema option must be set to use the validateForm method.');\n            }\n            const result = opts.update\n                ? await Form_clientValidation({ paths: [] }, true, opts.schema)\n                : Form_validate({ adapter: opts.schema });\n            if (opts.update && EnhancedForm) {\n                // Focus on first error field\n                setTimeout(() => {\n                    if (EnhancedForm)\n                        scrollToFirstError(EnhancedForm, {\n                            ...options,\n                            scrollToError: opts.focusOnError === false ? 'off' : options.scrollToError\n                        });\n                }, 1);\n            }\n            return result || Form_validate({ adapter: opts.schema });\n        },\n        allErrors: AllErrors,\n        posted: Posted,\n        reset(options) {\n            return Form_reset({\n                message: options?.keepMessage ? Data.message : undefined,\n                data: options?.data,\n                id: options?.id,\n                newState: options?.newState\n            });\n        },\n        submit(submitter) {\n            const form = EnhancedForm\n                ? EnhancedForm\n                : submitter && submitter instanceof HTMLElement\n                    ? submitter.closest('form')\n                    : undefined;\n            if (!form) {\n                throw new SuperFormError('use:enhance must be added to the form to use submit, or pass a HTMLElement inside the form (or the form itself) as an argument.');\n            }\n            const isSubmitButton = submitter &&\n                ((submitter instanceof HTMLButtonElement && submitter.type == 'submit') ||\n                    (submitter instanceof HTMLInputElement && ['submit', 'image'].includes(submitter.type)));\n            form.requestSubmit(isSubmitButton ? submitter : undefined);\n        },\n        isTainted: Tainted_isTainted,\n        ///// Custom use:enhance ////////////////////////////////////////\n        // @DCI-context\n        enhance(FormElement, events) {\n            EnhancedForm = FormElement;\n            if (events) {\n                if (events.onError) {\n                    if (options.onError === 'apply') {\n                        throw new SuperFormError('options.onError is set to \"apply\", cannot add any onError events.');\n                    }\n                    else if (events.onError === 'apply') {\n                        throw new SuperFormError('Cannot add \"apply\" as onError event in use:enhance.');\n                    }\n                    formEvents.onError.push(events.onError);\n                }\n                if (events.onResult)\n                    formEvents.onResult.push(events.onResult);\n                if (events.onSubmit)\n                    formEvents.onSubmit.push(events.onSubmit);\n                if (events.onUpdate)\n                    formEvents.onUpdate.push(events.onUpdate);\n                if (events.onUpdated)\n                    formEvents.onUpdated.push(events.onUpdated);\n            }\n            // Now we know that we are enhanced,\n            // so we can enable the tainted form option.\n            Tainted_enable();\n            let lastInputChange;\n            // TODO: Debounce option?\n            async function onInput(e) {\n                const info = inputInfo(e.target);\n                // Need to wait for immediate updates due to some timing issue\n                if (info.immediate && !info.file)\n                    await new Promise((r) => setTimeout(r, 0));\n                lastInputChange = NextChange_paths();\n                NextChange_additionalEventInformation('input', info.immediate, info.multiple, FormElement, e.target ?? undefined);\n            }\n            async function onBlur(e) {\n                // Avoid triggering client-side validation while submitting\n                if (Data.submitting)\n                    return;\n                if (!lastInputChange || NextChange_paths() != lastInputChange) {\n                    return;\n                }\n                const info = inputInfo(e.target);\n                // Need to wait for immediate updates due to some timing issue\n                if (info.immediate && !info.file)\n                    await new Promise((r) => setTimeout(r, 0));\n                Form_clientValidation({\n                    paths: lastInputChange,\n                    immediate: info.multiple,\n                    multiple: info.multiple,\n                    type: 'blur',\n                    formElement: FormElement,\n                    target: e.target ?? undefined\n                });\n                // Clear input change event, now that the field doesn't have focus anymore.\n                lastInputChange = undefined;\n            }\n            FormElement.addEventListener('focusout', onBlur);\n            FormElement.addEventListener('input', onInput);\n            onDestroy(() => {\n                FormElement.removeEventListener('focusout', onBlur);\n                FormElement.removeEventListener('input', onInput);\n                EnhancedForm = undefined;\n            });\n            ///// SvelteKit enhance function //////////////////////////////////\n            const htmlForm = HtmlForm(FormElement, { submitting: Submitting, delayed: Delayed, timeout: Timeout }, options);\n            let currentRequest;\n            return enhance(FormElement, async (submitParams) => {\n                let jsonData = undefined;\n                let validationAdapter = options.validators;\n                const submit = {\n                    ...submitParams,\n                    jsonData(data) {\n                        if (options.dataType !== 'json') {\n                            throw new SuperFormError(\"options.dataType must be set to 'json' to use jsonData.\");\n                        }\n                        jsonData = data;\n                    },\n                    validators(adapter) {\n                        validationAdapter = adapter;\n                    }\n                };\n                const _submitCancel = submit.cancel;\n                let cancelled = false;\n                function cancel(resetTimers = true) {\n                    cancelled = true;\n                    if (resetTimers && htmlForm.isSubmitting()) {\n                        htmlForm.completed({ cancelled });\n                    }\n                    return _submitCancel();\n                }\n                submit.cancel = cancel;\n                if (htmlForm.isSubmitting() && options.multipleSubmits == 'prevent') {\n                    cancel(false);\n                }\n                else {\n                    if (htmlForm.isSubmitting() && options.multipleSubmits == 'abort') {\n                        if (currentRequest)\n                            currentRequest.abort();\n                    }\n                    htmlForm.submitting();\n                    currentRequest = submit.controller;\n                    for (const event of formEvents.onSubmit) {\n                        await event(submit);\n                    }\n                }\n                if (cancelled) {\n                    if (options.flashMessage)\n                        cancelFlash(options);\n                }\n                else {\n                    // Client validation\n                    const noValidate = !options.SPA &&\n                        (FormElement.noValidate ||\n                            ((submit.submitter instanceof HTMLButtonElement ||\n                                submit.submitter instanceof HTMLInputElement) &&\n                                submit.submitter.formNoValidate));\n                    let validation = undefined;\n                    const validateForm = async () => {\n                        return await Form_validate({ adapter: validationAdapter });\n                    };\n                    if (!noValidate) {\n                        validation = await validateForm();\n                        if (!validation.valid) {\n                            cancel(false);\n                            const result = {\n                                type: 'failure',\n                                status: (typeof options.SPA === 'boolean' ? undefined : options.SPA?.failStatus) ?? 400,\n                                data: { form: validation }\n                            };\n                            setTimeout(() => validationResponse({ result }), 0);\n                        }\n                    }\n                    if (!cancelled) {\n                        switch (options.clearOnSubmit) {\n                            case 'errors-and-message':\n                                Errors.clear();\n                                Message.set(undefined);\n                                break;\n                            case 'errors':\n                                Errors.clear();\n                                break;\n                            case 'message':\n                                Message.set(undefined);\n                                break;\n                        }\n                        if (options.flashMessage &&\n                            (options.clearOnSubmit == 'errors-and-message' ||\n                                options.clearOnSubmit == 'message') &&\n                            shouldSyncFlash(options)) {\n                            options.flashMessage.module.getFlash(page).set(undefined);\n                        }\n                        // Deprecation fix\n                        const submitData = 'formData' in submit ? submit.formData : submit.data;\n                        // Prevent input/blur events to trigger client-side validation,\n                        // and accidentally removing errors set by setError\n                        lastInputChange = undefined;\n                        if (options.SPA) {\n                            cancel(false);\n                            if (!validation)\n                                validation = await validateForm();\n                            const validationResult = { ...validation, posted: true };\n                            const result = {\n                                type: validationResult.valid ? 'success' : 'failure',\n                                status: validationResult.valid\n                                    ? 200\n                                    : typeof options.SPA == 'object'\n                                        ? options.SPA?.failStatus\n                                        : 400 ?? 400,\n                                data: { form: validationResult }\n                            };\n                            setTimeout(() => validationResponse({ result }), 0);\n                        }\n                        else if (options.dataType === 'json') {\n                            if (!validation)\n                                validation = await validateForm();\n                            const postData = clone(jsonData ?? validation.data);\n                            // Move files to form data, since they cannot be serialized.\n                            // Will be reassembled in superValidate.\n                            traversePaths(postData, (data) => {\n                                if (data.value instanceof File) {\n                                    const key = '__superform_file_' + mergePath(data.path);\n                                    submitData.append(key, data.value);\n                                    return data.set(undefined);\n                                }\n                                else if (Array.isArray(data.value) &&\n                                    data.value.length &&\n                                    data.value.every((v) => v instanceof File)) {\n                                    const key = '__superform_files_' + mergePath(data.path);\n                                    for (const file of data.value) {\n                                        submitData.append(key, file);\n                                    }\n                                    return data.set(undefined);\n                                }\n                            });\n                            // Clear post data to reduce transfer size,\n                            // since $form should be serialized and sent as json.\n                            Object.keys(postData).forEach((key) => {\n                                // Files should be kept though, even if same key.\n                                if (typeof submitData.get(key) === 'string') {\n                                    submitData.delete(key);\n                                }\n                            });\n                            // Split the form data into chunks, in case it gets too large for proxy servers\n                            const chunks = chunkSubstr(stringify(postData), options.jsonChunkSize ?? 500000);\n                            for (const chunk of chunks) {\n                                submitData.append('__superform_json', chunk);\n                            }\n                        }\n                        if (!options.SPA && !submitData.has('__superform_id')) {\n                            // Add formId\n                            const id = Data.formId;\n                            if (id !== undefined)\n                                submitData.set('__superform_id', id);\n                        }\n                    }\n                }\n                // Thanks to https://stackoverflow.com/a/29202760/70894\n                function chunkSubstr(str, size) {\n                    const numChunks = Math.ceil(str.length / size);\n                    const chunks = new Array(numChunks);\n                    for (let i = 0, o = 0; i < numChunks; ++i, o += size) {\n                        chunks[i] = str.substring(o, o + size);\n                    }\n                    return chunks;\n                }\n                async function validationResponse(event) {\n                    // Check if an error was thrown in hooks, in which case it has no type.\n                    const result = event.result.type\n                        ? event.result\n                        : {\n                            type: 'error',\n                            status: 500,\n                            error: event.result\n                        };\n                    currentRequest = null;\n                    let cancelled = false;\n                    const cancel = () => (cancelled = true);\n                    const data = {\n                        result,\n                        formEl: FormElement,\n                        formElement: FormElement,\n                        cancel\n                    };\n                    // Check for goto to a different route in the events\n                    const unsubCheckforNav = navigating.subscribe(($nav) => {\n                        if (!$nav || $nav.from?.route.id === $nav.to?.route.id)\n                            return;\n                        cancel();\n                    });\n                    for (const event of formEvents.onResult) {\n                        await event(data);\n                    }\n                    if (!cancelled) {\n                        if ((result.type === 'success' || result.type == 'failure') && result.data) {\n                            const forms = Context_findValidationForms(result.data);\n                            if (!forms.length) {\n                                throw new SuperFormError('No form data returned from ActionResult. Make sure you return { form } in the form actions.');\n                            }\n                            for (const newForm of forms) {\n                                if (newForm.id !== Data.formId)\n                                    continue;\n                                const data = {\n                                    form: newForm,\n                                    formEl: FormElement,\n                                    formElement: FormElement,\n                                    cancel: () => (cancelled = true)\n                                };\n                                for (const event of formEvents.onUpdate) {\n                                    await event(data);\n                                }\n                                if (!cancelled) {\n                                    if (options.customValidity) {\n                                        setCustomValidityForm(FormElement, data.form.errors);\n                                    }\n                                    // Special reset case for file inputs\n                                    if (Form_shouldReset(data.form.valid, result.type == 'success')) {\n                                        data.formElement\n                                            .querySelectorAll('input[type=\"file\"]')\n                                            .forEach((e) => (e.value = ''));\n                                    }\n                                }\n                            }\n                        }\n                        if (!cancelled) {\n                            if (result.type !== 'error') {\n                                if (result.type === 'success' && options.invalidateAll) {\n                                    await invalidateAll();\n                                }\n                                if (options.applyAction) {\n                                    // This will trigger the page subscription in superForm,\n                                    // which will in turn call Data_update.\n                                    await applyAction(result);\n                                }\n                                else {\n                                    // Call Data_update directly to trigger events\n                                    await Form_updateFromActionResult(result);\n                                }\n                            }\n                            else {\n                                // Error result\n                                if (options.applyAction) {\n                                    if (options.onError == 'apply') {\n                                        await applyAction(result);\n                                    }\n                                    else {\n                                        // Transform to failure, to avoid data loss\n                                        // Set the data to the error result, so it will be\n                                        // picked up in page.subscribe in superForm.\n                                        const failResult = {\n                                            type: 'failure',\n                                            status: Math.floor(result.status || 500),\n                                            data: result\n                                        };\n                                        await applyAction(failResult);\n                                    }\n                                }\n                                // Check if the error message should be replaced\n                                if (options.onError !== 'apply') {\n                                    const data = { result, message: Message };\n                                    for (const onErrorEvent of formEvents.onError) {\n                                        if (onErrorEvent !== 'apply' &&\n                                            (onErrorEvent != defaultOnError || !options.flashMessage?.onError)) {\n                                            await onErrorEvent(data);\n                                        }\n                                    }\n                                }\n                            }\n                            // Trigger flash message event if there was an error\n                            if (options.flashMessage) {\n                                if (result.type == 'error' && options.flashMessage.onError) {\n                                    await options.flashMessage.onError({\n                                        result,\n                                        flashMessage: options.flashMessage.module.getFlash(page)\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    if (cancelled && options.flashMessage) {\n                        cancelFlash(options);\n                    }\n                    // Redirect messages are handled in onDestroy and afterNavigate in client/form.ts.\n                    if (cancelled || result.type != 'redirect') {\n                        htmlForm.completed({ cancelled });\n                    }\n                    else {\n                        const unsub = navigating.subscribe(($nav) => {\n                            if ($nav)\n                                return;\n                            // Timeout required when applyAction is false\n                            setTimeout(() => {\n                                try {\n                                    if (unsub)\n                                        unsub();\n                                }\n                                catch {\n                                    // If component is already destroyed?\n                                }\n                            });\n                            if (htmlForm.isSubmitting()) {\n                                htmlForm.completed({ cancelled, clearAll: true });\n                            }\n                        });\n                    }\n                    unsubCheckforNav();\n                }\n                return validationResponse;\n            });\n        }\n    };\n}\n", "import { browser } from '$app/environment';\nexport function cancelFlash(options) {\n    if (!options.flashMessage || !browser)\n        return;\n    if (!shouldSyncFlash(options))\n        return;\n    document.cookie = `flash=; Max-Age=0; Path=${options.flashMessage.cookiePath ?? '/'};`;\n}\nexport function shouldSyncFlash(options) {\n    if (!options.flashMessage || !browser)\n        return false;\n    return options.syncFlashMessage;\n}\n", "import { splitPath } from '../stringPath.js';\nimport { traversePath } from '../traversal.js';\nconst noCustomValidityDataAttribute = 'noCustomValidity';\nexport async function updateCustomValidity(validityEl, errors) {\n    // Always reset validity, in case it has been validated on the server.\n    if ('setCustomValidity' in validityEl) {\n        validityEl.setCustomValidity('');\n    }\n    if (noCustomValidityDataAttribute in validityEl.dataset)\n        return;\n    setCustomValidity(validityEl, errors);\n}\nexport function setCustomValidityForm(formElement, errors) {\n    for (const el of formElement.querySelectorAll('input,select,textarea,button')) {\n        if (noCustomValidityDataAttribute in el.dataset) {\n            continue;\n        }\n        const error = traversePath(errors, splitPath(el.name));\n        setCustomValidity(el, error?.value);\n        if (error?.value)\n            return;\n    }\n}\nfunction setCustomValidity(el, errors) {\n    const message = errors && errors.length ? errors.join('\\n') : '';\n    el.setCustomValidity(message);\n    if (message)\n        el.reportValidity();\n}\n", "// https://stackoverflow.com/a/7557433/70894\nexport const isElementInViewport = (el, topOffset = 0) => {\n    const rect = el.getBoundingClientRect();\n    return (rect.top >= topOffset &&\n        rect.left >= 0 &&\n        rect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight) /* or $(window).height() */ &&\n        rect.right <=\n            (window.innerWidth || document.documentElement.clientWidth) /* or $(window).width() */);\n};\n// https://stackoverflow.com/a/36499256/70894\nexport const scrollToAndCenter = (el, offset = 1.125, behavior = 'smooth') => {\n    const elementRect = el.getBoundingClientRect();\n    const absoluteElementTop = elementRect.top + window.pageYOffset;\n    const top = absoluteElementTop - window.innerHeight / (2 * offset);\n    window.scrollTo({ left: 0, top, behavior });\n};\nconst immediateInputTypes = ['checkbox', 'radio', 'range', 'file'];\n/**\n * Information about a HTML element, for determining when to display errors.\n */\nexport function inputInfo(el) {\n    const immediate = !!el &&\n        (el instanceof HTMLSelectElement ||\n            (el instanceof HTMLInputElement && immediateInputTypes.includes(el.type)));\n    const multiple = !!el && el instanceof HTMLSelectElement && el.multiple;\n    const file = !!el && el instanceof HTMLInputElement && el.type == 'file';\n    return { immediate, multiple, file };\n}\n", "import { isElementInViewport, scrollToAndCenter } from './elements.js';\nimport { onDestroy, tick } from 'svelte';\nvar FetchStatus;\n(function (FetchStatus) {\n    FetchStatus[FetchStatus[\"Idle\"] = 0] = \"Idle\";\n    FetchStatus[FetchStatus[\"Submitting\"] = 1] = \"Submitting\";\n    FetchStatus[FetchStatus[\"Delayed\"] = 2] = \"Delayed\";\n    FetchStatus[FetchStatus[\"Timeout\"] = 3] = \"Timeout\";\n})(FetchStatus || (FetchStatus = {}));\nconst activeTimers = new Set();\n//let _initialized = false;\n/**\n * @DCI-context\n */\nexport function Form(formElement, timers, options) {\n    let state = FetchStatus.Idle;\n    let delayedTimeout, timeoutTimeout;\n    //#region Timers\n    const Timers = activeTimers;\n    // https://www.nngroup.com/articles/response-times-3-important-limits/\n    function Timers_start() {\n        Timers_clear();\n        Timers_setState(state != FetchStatus.Delayed ? FetchStatus.Submitting : FetchStatus.Delayed);\n        delayedTimeout = window.setTimeout(() => {\n            if (delayedTimeout && state == FetchStatus.Submitting)\n                Timers_setState(FetchStatus.Delayed);\n        }, options.delayMs);\n        timeoutTimeout = window.setTimeout(() => {\n            if (timeoutTimeout && state == FetchStatus.Delayed)\n                Timers_setState(FetchStatus.Timeout);\n        }, options.timeoutMs);\n        Timers.add(Timers_clear);\n    }\n    /**\n     * Clear timers and set state to Idle.\n     */\n    function Timers_clear() {\n        clearTimeout(delayedTimeout);\n        clearTimeout(timeoutTimeout);\n        delayedTimeout = timeoutTimeout = 0;\n        Timers.delete(Timers_clear);\n        Timers_setState(FetchStatus.Idle);\n    }\n    function Timers_clearAll() {\n        Timers.forEach((t) => t());\n        Timers.clear();\n    }\n    function Timers_setState(s) {\n        state = s;\n        timers.submitting.set(state >= FetchStatus.Submitting);\n        timers.delayed.set(state >= FetchStatus.Delayed);\n        timers.timeout.set(state >= FetchStatus.Timeout);\n    }\n    //#endregion\n    //#region ErrorTextEvents\n    const ErrorTextEvents = formElement;\n    function ErrorTextEvents__selectText(e) {\n        const target = e.target;\n        if (options.selectErrorText)\n            target.select();\n    }\n    function ErrorTextEvents_addErrorTextListeners() {\n        if (!options.selectErrorText)\n            return;\n        ErrorTextEvents.querySelectorAll('input').forEach((el) => {\n            el.addEventListener('invalid', ErrorTextEvents__selectText);\n        });\n    }\n    function ErrorTextEvents_removeErrorTextListeners() {\n        if (!options.selectErrorText)\n            return;\n        ErrorTextEvents.querySelectorAll('input').forEach((el) => el.removeEventListener('invalid', ErrorTextEvents__selectText));\n    }\n    //#endregion\n    //#region Form\n    const Form = formElement;\n    //#endregion\n    {\n        ErrorTextEvents_addErrorTextListeners();\n        const completed = (opts) => {\n            if (!opts.clearAll)\n                Timers_clear();\n            else\n                Timers_clearAll();\n            if (!opts.cancelled)\n                setTimeout(() => scrollToFirstError(Form, options), 1);\n        };\n        onDestroy(() => {\n            ErrorTextEvents_removeErrorTextListeners();\n            completed({ cancelled: true });\n        });\n        return {\n            submitting() {\n                Timers_start();\n            },\n            completed,\n            scrollToFirstError() {\n                setTimeout(() => scrollToFirstError(Form, options), 1);\n            },\n            isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed\n        };\n    }\n}\nexport const scrollToFirstError = async (Form, options) => {\n    if (options.scrollToError == 'off')\n        return;\n    const selector = options.errorSelector;\n    if (!selector)\n        return;\n    // Wait for form to update with errors\n    await tick();\n    // Scroll to first form message, if not visible\n    let el;\n    el = Form.querySelector(selector);\n    if (!el)\n        return;\n    // Find underlying element if it is a FormGroup element\n    el = el.querySelector(selector) ?? el;\n    const nav = options.stickyNavbar\n        ? document.querySelector(options.stickyNavbar)\n        : null;\n    if (typeof options.scrollToError != 'string') {\n        el.scrollIntoView(options.scrollToError);\n    }\n    else if (!isElementInViewport(el, nav?.offsetHeight ?? 0)) {\n        scrollToAndCenter(el, undefined, options.scrollToError);\n    }\n    function Form_shouldAutoFocus(userAgent) {\n        if (typeof options.autoFocusOnError === 'boolean')\n            return options.autoFocusOnError;\n        else\n            return !/iPhone|iPad|iPod|Android/i.test(userAgent);\n    }\n    // Don't focus on the element if on mobile, it will open the keyboard\n    // and probably hide the error message.\n    if (!Form_shouldAutoFocus(navigator.userAgent))\n        return;\n    let focusEl;\n    focusEl = el;\n    if (!['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes(focusEl.tagName)) {\n        focusEl = focusEl.querySelector('input:not([type=\"hidden\"]):not(.flatpickr-input), select, textarea');\n    }\n    if (focusEl) {\n        try {\n            focusEl.focus({ preventScroll: true });\n            if (options.selectErrorText && focusEl.tagName == 'INPUT') {\n                focusEl.select();\n            }\n        }\n        catch (err) {\n            // Some hidden inputs like from flatpickr cannot be focused.\n        }\n    }\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { derived, get } from 'svelte/store';\nimport { SuperFormError } from '../errors.js';\nimport { pathExists, traversePath } from '../traversal.js';\nimport { splitPath } from '../stringPath.js';\nconst defaultOptions = {\n    trueStringValue: 'true',\n    dateFormat: 'iso'\n};\n///// Proxy functions ///////////////////////////////////////////////\nexport function booleanProxy(form, path, options) {\n    return _stringProxy(form, path, 'boolean', {\n        ...defaultOptions,\n        ...options\n    });\n}\nexport function intProxy(form, path, options) {\n    return _stringProxy(form, path, 'int', {\n        ...defaultOptions,\n        ...options\n    });\n}\nexport function numberProxy(form, path, options) {\n    return _stringProxy(form, path, 'number', {\n        ...defaultOptions,\n        ...options\n    });\n}\nexport function dateProxy(form, path, options) {\n    return _stringProxy(form, path, 'date', {\n        ...defaultOptions,\n        dateFormat: options?.format ?? 'iso',\n        empty: options?.empty\n    });\n}\nexport function stringProxy(form, path, options) {\n    return _stringProxy(form, path, 'string', {\n        ...defaultOptions,\n        ...options\n    });\n}\n///// Implementation ////////////////////////////////////////////////\n/**\n * Creates a string store that will pass its value to a field in the form.\n * @param form The form\n * @param field Form field\n * @param type 'number' | 'int' | 'boolean'\n */\nfunction _stringProxy(form, path, type, options) {\n    function toValue(value) {\n        if (!value && options.empty !== undefined) {\n            return options.empty === 'null' ? null : options.empty === 'zero' ? 0 : undefined;\n        }\n        if (typeof value === 'number') {\n            value = value.toString();\n        }\n        if (typeof value !== 'string') {\n            // Can be undefined due to Proxy in Svelte 5\n            value = '';\n        }\n        const stringValue = value;\n        if (type == 'string')\n            return stringValue;\n        else if (type == 'boolean')\n            return !!stringValue;\n        else if (type == 'date')\n            return new Date(stringValue);\n        const numberToConvert = options.delimiter\n            ? stringValue.replace(options.delimiter, '.')\n            : stringValue;\n        let num;\n        if (numberToConvert === '' && options.empty == 'zero')\n            num = 0;\n        else if (type == 'number')\n            num = parseFloat(numberToConvert);\n        else\n            num = parseInt(numberToConvert, 10);\n        return num;\n    }\n    const isSuper = isSuperForm(form, options);\n    const realProxy = isSuper\n        ? superFieldProxy(form, path, { taint: options.taint })\n        : fieldProxy(form, path);\n    let updatedValue = null;\n    let initialized = false;\n    const proxy = derived(realProxy, (value) => {\n        if (!initialized) {\n            initialized = true;\n            if (options.initiallyEmptyIfZero && !value)\n                return '';\n        }\n        // Prevent proxy updating itself\n        if (updatedValue !== null) {\n            const current = updatedValue;\n            updatedValue = null;\n            return current;\n        }\n        if (value === undefined || value === null)\n            return '';\n        if (type == 'string') {\n            return value;\n        }\n        else if (type == 'int' || type == 'number') {\n            if (value === '') {\n                // Special case for empty string values in number proxies\n                // Set the value to 0, to conform to the type.\n                realProxy.set(0, isSuper ? { taint: false } : undefined);\n            }\n            if (typeof value === 'number' && isNaN(value))\n                return '';\n            return String(value);\n        }\n        else if (type == 'date') {\n            const date = value;\n            if (isNaN(date))\n                return '';\n            switch (options.dateFormat) {\n                case 'iso':\n                    return date.toISOString();\n                case 'date':\n                    return date.toISOString().slice(0, 10);\n                case 'datetime':\n                    return date.toISOString().slice(0, 16);\n                case 'time':\n                    return date.toISOString().slice(11, 16);\n                case 'date-utc':\n                    return UTCDate(date);\n                case 'datetime-utc':\n                    return UTCDate(date) + 'T' + UTCTime(date);\n                case 'time-utc':\n                    return UTCTime(date);\n                case 'date-local':\n                    return localDate(date);\n                case 'datetime-local':\n                    return localDate(date) + 'T' + localTime(date);\n                case 'time-local':\n                    return localTime(date);\n            }\n        }\n        else {\n            // boolean\n            return value ? options.trueStringValue : '';\n        }\n    });\n    return {\n        subscribe: proxy.subscribe,\n        set(val) {\n            updatedValue = val;\n            const newValue = toValue(updatedValue);\n            realProxy.set(newValue);\n        },\n        update(updater) {\n            realProxy.update((f) => {\n                updatedValue = updater(String(f));\n                const newValue = toValue(updatedValue);\n                return newValue;\n            });\n        }\n    };\n}\nexport function arrayProxy(superForm, path, options) {\n    const formErrors = fieldProxy(superForm.errors, `${path}`);\n    const onlyFieldErrors = derived(formErrors, ($errors) => {\n        const output = [];\n        for (const key in $errors) {\n            if (key == '_errors')\n                continue;\n            output[key] = $errors[key];\n        }\n        return output;\n    });\n    function updateArrayErrors(errors, value) {\n        for (const key in errors) {\n            if (key == '_errors')\n                continue;\n            errors[key] = undefined;\n        }\n        if (value !== undefined) {\n            for (const key in value) {\n                errors[key] = value[key];\n            }\n        }\n        return errors;\n    }\n    const fieldErrors = {\n        subscribe: onlyFieldErrors.subscribe,\n        update(upd) {\n            formErrors.update(($errors) => \n            // @ts-expect-error Type is correct\n            updateArrayErrors($errors, upd($errors)));\n        },\n        set(value) {\n            // @ts-expect-error Type is correct\n            formErrors.update(($errors) => updateArrayErrors($errors, value));\n        }\n    };\n    const values = superFieldProxy(superForm, path, options);\n    // If array is shortened, delete all keys above length\n    // in errors, so they won't be kept if the array is lengthened again.\n    let lastLength = Array.isArray(get(values)) ? get(values).length : 0;\n    values.subscribe(($values) => {\n        const currentLength = Array.isArray($values) ? $values.length : 0;\n        if (currentLength < lastLength) {\n            superForm.errors.update(($errors) => {\n                const node = pathExists($errors, splitPath(path));\n                if (!node)\n                    return $errors;\n                for (const key in node.value) {\n                    if (Number(key) < currentLength)\n                        continue;\n                    delete node.value[key];\n                }\n                return $errors;\n            }, { force: true });\n        }\n        lastLength = currentLength;\n    });\n    return {\n        path,\n        values: values,\n        errors: fieldProxy(superForm.errors, `${path}._errors`),\n        valueErrors: fieldErrors\n    };\n}\nexport function formFieldProxy(superForm, path, options) {\n    const path2 = splitPath(path);\n    // Filter out array indices, the constraints structure doesn't contain these.\n    const constraintsPath = path2.filter((p) => /\\D/.test(String(p))).join('.');\n    const taintedProxy = derived(superForm.tainted, ($tainted) => {\n        if (!$tainted)\n            return $tainted;\n        const taintedPath = traversePath($tainted, path2);\n        return taintedPath ? taintedPath.value : undefined;\n    });\n    const tainted = {\n        subscribe: taintedProxy.subscribe,\n        update(upd) {\n            superForm.tainted.update(($tainted) => {\n                if (!$tainted)\n                    $tainted = {};\n                const output = traversePath($tainted, path2, (path) => {\n                    if (!path.value)\n                        path.parent[path.key] = {};\n                    return path.parent[path.key];\n                });\n                if (output)\n                    output.parent[output.key] = upd(output.value);\n                return $tainted;\n            });\n        },\n        set(value) {\n            superForm.tainted.update(($tainted) => {\n                if (!$tainted)\n                    $tainted = {};\n                const output = traversePath($tainted, path2, (path) => {\n                    if (!path.value)\n                        path.parent[path.key] = {};\n                    return path.parent[path.key];\n                });\n                if (output)\n                    output.parent[output.key] = value;\n                return $tainted;\n            });\n        }\n    };\n    return {\n        path,\n        value: superFieldProxy(superForm, path, options),\n        errors: fieldProxy(superForm.errors, path),\n        constraints: fieldProxy(superForm.constraints, constraintsPath),\n        tainted\n    };\n}\nfunction updateProxyField(obj, path, updater) {\n    const output = traversePath(obj, path, ({ parent, key, value }) => {\n        if (value === undefined)\n            parent[key] = /\\D/.test(key) ? {} : [];\n        return parent[key];\n    });\n    if (output) {\n        const newValue = updater(output.value);\n        output.parent[output.key] = newValue;\n    }\n    return obj;\n}\nfunction superFieldProxy(superForm, path, baseOptions) {\n    const form = superForm.form;\n    const path2 = splitPath(path);\n    const proxy = derived(form, ($form) => {\n        const data = traversePath($form, path2);\n        return data?.value;\n    });\n    return {\n        subscribe(...params) {\n            const unsub = proxy.subscribe(...params);\n            return () => unsub();\n        },\n        update(upd, options) {\n            form.update((data) => updateProxyField(data, path2, upd), options ?? baseOptions);\n        },\n        set(value, options) {\n            form.update((data) => updateProxyField(data, path2, () => value), options ?? baseOptions);\n        }\n    };\n}\nfunction isSuperForm(form, options) {\n    const isSuperForm = 'form' in form;\n    if (!isSuperForm && options?.taint !== undefined) {\n        throw new SuperFormError('If options.taint is set, the whole superForm object must be used as a proxy.');\n    }\n    return isSuperForm;\n}\nexport function fieldProxy(form, path, options) {\n    const path2 = splitPath(path);\n    if (isSuperForm(form, options)) {\n        return superFieldProxy(form, path, options);\n    }\n    const proxy = derived(form, ($form) => {\n        const data = traversePath($form, path2);\n        return data?.value;\n    });\n    return {\n        subscribe(...params) {\n            const unsub = proxy.subscribe(...params);\n            return () => unsub();\n        },\n        update(upd) {\n            form.update((data) => updateProxyField(data, path2, upd));\n        },\n        set(value) {\n            form.update((data) => updateProxyField(data, path2, () => value));\n        }\n    };\n}\nfunction localDate(date) {\n    return (date.getFullYear() +\n        '-' +\n        String(date.getMonth() + 1).padStart(2, '0') +\n        '-' +\n        String(date.getDate()).padStart(2, '0'));\n}\nfunction localTime(date) {\n    return (String(date.getHours()).padStart(2, '0') + ':' + String(date.getMinutes()).padStart(2, '0'));\n}\nfunction UTCDate(date) {\n    return (date.getUTCFullYear() +\n        '-' +\n        String(date.getUTCMonth() + 1).padStart(2, '0') +\n        '-' +\n        String(date.getUTCDate()).padStart(2, '0'));\n}\nfunction UTCTime(date) {\n    return (String(date.getUTCHours()).padStart(2, '0') +\n        ':' +\n        String(date.getUTCMinutes()).padStart(2, '0'));\n}\n/*\nfunction dateToUTC(date: Date) {\n  return new Date(\n    date.getUTCFullYear(),\n    date.getUTCMonth(),\n    date.getUTCDate(),\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds()\n  );\n}\n*/\n", "export function defaults(data, adapter, options) {\n    if (data && 'superFormValidationLibrary' in data) {\n        options = adapter;\n        adapter = data;\n        data = null;\n    }\n    const validator = adapter;\n    const optionDefaults = options?.defaults ?? validator.defaults;\n    return {\n        id: options?.id ?? validator.id ?? '',\n        valid: false,\n        posted: false,\n        errors: {},\n        data: { ...optionDefaults, ...data },\n        constraints: validator.constraints,\n        shape: validator.shape\n    };\n}\nexport function defaultValues(adapter) {\n    return adapter.defaults;\n}\n", "import { json } from '@sveltejs/kit';\nimport { stringify } from 'devalue';\nexport function actionResult(type, data, options) {\n    function cookieData() {\n        if (typeof options === 'number' || !options?.message)\n            return '';\n        const extra = [\n            `Path=${options?.cookieOptions?.path || '/'}`,\n            `Max-Age=${options?.cookieOptions?.maxAge || 120}`,\n            `SameSite=${options?.cookieOptions?.sameSite ?? 'Strict'}`\n        ];\n        if (options?.cookieOptions?.secure) {\n            extra.push(`Secure`);\n        }\n        return `flash=${encodeURIComponent(JSON.stringify(options.message))}; ` + extra.join('; ');\n    }\n    const status = options && typeof options !== 'number' ? options.status : options;\n    const result = (struct) => {\n        return json({ type, ...struct }, {\n            status: struct.status,\n            headers: typeof options === 'object' && options.message\n                ? {\n                    'Set-Cookie': cookieData()\n                }\n                : undefined\n        });\n    };\n    if (type == 'error') {\n        return result({\n            status: status || 500,\n            error: typeof data === 'string' ? { message: data } : data\n        });\n    }\n    else if (type == 'redirect') {\n        return result({\n            status: status || 303,\n            location: data\n        });\n    }\n    else if (type == 'failure') {\n        return result({\n            status: status || 400,\n            data: stringify(data)\n        });\n    }\n    else {\n        return result({ status: status || 200, data: stringify(data) });\n    }\n}\n", "import { traversePath } from './traversal.js';\nimport { fail } from '@sveltejs/kit';\nimport {} from './adapters/adapters.js';\nimport { parseRequest } from './formData.js';\nimport { splitPath } from './stringPath.js';\nimport { mapErrors, mergeDefaults, replaceInvalidDefaults } from './errors.js';\n/**\n * Validates a schema for data validation and usage in superForm.\n * @param data Data corresponding to a schema, or RequestEvent/FormData/URL. If falsy, the schema's default values will be used.\n * @param schema The schema to validate against.\n */\nexport async function superValidate(data, adapter, options) {\n    if (data && 'superFormValidationLibrary' in data) {\n        options = adapter;\n        adapter = data;\n        data = undefined;\n    }\n    const validator = adapter;\n    const defaults = options?.defaults ?? validator.defaults;\n    const jsonSchema = validator.jsonSchema;\n    const parsed = await parseRequest(data, jsonSchema, options);\n    const addErrors = options?.errors ?? (options?.strict ? true : !!parsed.data);\n    // Merge with defaults in non-strict mode.\n    const parsedData = options?.strict ? parsed.data ?? {} : mergeDefaults(parsed.data, defaults);\n    let status;\n    if (!!parsed.data || addErrors) {\n        status = await /* @__PURE__ */ validator.validate(parsedData);\n    }\n    else {\n        status = { success: false, issues: [] };\n    }\n    const valid = status.success;\n    const errors = valid || !addErrors ? {} : mapErrors(status.issues, validator.shape);\n    // Final data should always have defaults, to ensure type safety\n    //const dataWithDefaults = { ...defaults, ...(valid ? status.data : parsedData) };\n    const dataWithDefaults = valid\n        ? status.data\n        : replaceInvalidDefaults(options?.strict ? mergeDefaults(parsedData, defaults) : parsedData, defaults, jsonSchema, status.issues, options?.preprocessed);\n    let outputData;\n    if (jsonSchema.additionalProperties === false) {\n        // Strip keys not belonging to schema\n        outputData = {};\n        for (const key of Object.keys(jsonSchema.properties ?? {})) {\n            if (key in dataWithDefaults)\n                outputData[key] = dataWithDefaults[key];\n        }\n    }\n    else {\n        outputData = dataWithDefaults;\n    }\n    const output = {\n        id: parsed.id ?? options?.id ?? validator.id,\n        valid,\n        posted: parsed.posted,\n        errors: errors,\n        data: outputData\n    };\n    if (!parsed.posted) {\n        output.constraints = validator.constraints;\n        if (Object.keys(validator.shape).length) {\n            output.shape = validator.shape;\n        }\n    }\n    return output;\n}\n/////////////////////////////////////////////////////////////////////\n/**\n * Sends a message with a form, with an optional HTTP status code that will set\n * form.valid to false if status >= 400. A status lower than 400 cannot be sent.\n */\nexport function message(form, message, options) {\n    if (options?.status && options.status >= 400) {\n        form.valid = false;\n    }\n    form.message = message;\n    const remove = options?.removeFiles !== false;\n    const output = remove ? withFiles({ form }) : { form };\n    return form.valid ? output : fail(options?.status ?? 400, output);\n}\nexport const setMessage = message;\nexport function setError(form, path, error, options) {\n    // Unify signatures\n    if (error == undefined || (typeof error !== 'string' && !Array.isArray(error))) {\n        options = error;\n        error = path;\n        path = '';\n    }\n    if (options === undefined)\n        options = {};\n    const errArr = Array.isArray(error) ? error : [error];\n    if (!form.errors)\n        form.errors = {};\n    if (path === null || path === '') {\n        if (!form.errors._errors)\n            form.errors._errors = [];\n        form.errors._errors = options.overwrite ? errArr : form.errors._errors.concat(errArr);\n    }\n    else {\n        const realPath = splitPath(path);\n        const leaf = traversePath(form.errors, realPath, ({ parent, key, value }) => {\n            if (value === undefined)\n                parent[key] = {};\n            return parent[key];\n        });\n        if (leaf) {\n            leaf.parent[leaf.key] =\n                Array.isArray(leaf.value) && !options.overwrite ? leaf.value.concat(errArr) : errArr;\n        }\n    }\n    form.valid = false;\n    const output = options.removeFiles === false ? { form } : withFiles({ form });\n    return fail(options.status ?? 400, output);\n}\nexport function withFiles(obj) {\n    if (typeof obj !== 'object')\n        return obj;\n    for (const key in obj) {\n        const value = obj[key];\n        if (value instanceof File)\n            delete obj[key];\n        else if (value && typeof value === 'object')\n            withFiles(value);\n    }\n    return obj;\n}\nexport const removeFiles = withFiles;\n", "import { SuperFormError, SchemaError } from './errors.js';\nimport { parse } from 'devalue';\nimport { schemaInfo } from './jsonSchema/schemaInfo.js';\nimport { defaultValues } from './jsonSchema/schemaDefaults.js';\nimport { setPaths } from './traversal.js';\nimport { splitPath } from './stringPath.js';\nimport { assertSchema } from './utils.js';\n/**\n * V1 compatibilty. resetForm = false and taintedMessage = true\n */\nlet legacyMode = false;\ntry {\n    // @ts-expect-error Vite define check\n    if (SUPERFORMS_LEGACY)\n        legacyMode = true;\n}\ncatch {\n    // No legacy mode defined\n}\nconst unionError = 'FormData parsing failed: Unions are only supported when the dataType option for superForm is set to \"json\".';\nexport async function parseRequest(data, schemaData, options) {\n    let parsed;\n    if (data instanceof FormData) {\n        parsed = parseFormData(data, schemaData, options);\n    }\n    else if (data instanceof URL || data instanceof URLSearchParams) {\n        parsed = parseSearchParams(data, schemaData, options);\n    }\n    else if (data instanceof Request) {\n        parsed = await tryParseFormData(data, schemaData, options);\n    }\n    else if (\n    // RequestEvent\n    data &&\n        typeof data === 'object' &&\n        'request' in data &&\n        data.request instanceof Request) {\n        parsed = await tryParseFormData(data.request, schemaData, options);\n    }\n    else {\n        parsed = {\n            id: undefined,\n            data: data,\n            posted: false\n        };\n    }\n    return parsed;\n}\nasync function tryParseFormData(request, schemaData, options) {\n    let formData = undefined;\n    try {\n        formData = await request.formData();\n    }\n    catch (e) {\n        if (e instanceof TypeError && e.message.includes('already been consumed')) {\n            // Pass through the \"body already consumed\" error, which applies to\n            // POST requests when event/request is used after formData has been fetched.\n            throw e;\n        }\n        // No data found, return an empty form\n        return { id: undefined, data: undefined, posted: false };\n    }\n    return parseFormData(formData, schemaData, options);\n}\nexport function parseSearchParams(data, schemaData, options) {\n    if (data instanceof URL)\n        data = data.searchParams;\n    const convert = new FormData();\n    for (const [key, value] of data.entries()) {\n        convert.append(key, value);\n    }\n    const output = parseFormData(convert, schemaData, options);\n    // Set posted to false since it's a URL\n    output.posted = false;\n    return output;\n}\nexport function parseFormData(formData, schemaData, options) {\n    function tryParseSuperJson() {\n        if (formData.has('__superform_json')) {\n            try {\n                const output = parse(formData.getAll('__superform_json').join('') ?? '');\n                if (typeof output === 'object') {\n                    // Restore uploaded files and add to data\n                    const filePaths = Array.from(formData.keys());\n                    for (const path of filePaths.filter((path) => path.startsWith('__superform_file_'))) {\n                        const realPath = splitPath(path.substring(17));\n                        setPaths(output, [realPath], formData.get(path));\n                    }\n                    for (const path of filePaths.filter((path) => path.startsWith('__superform_files_'))) {\n                        const realPath = splitPath(path.substring(18));\n                        const allFiles = formData.getAll(path);\n                        setPaths(output, [realPath], Array.from(allFiles));\n                    }\n                    return output;\n                }\n            }\n            catch {\n                //\n            }\n        }\n        return null;\n    }\n    const data = tryParseSuperJson();\n    const id = formData.get('__superform_id')?.toString();\n    return data\n        ? { id, data, posted: true }\n        : {\n            id,\n            data: _parseFormData(formData, schemaData, options),\n            posted: true\n        };\n}\nfunction _parseFormData(formData, schema, options) {\n    const output = {};\n    const schemaKeys = options?.strict\n        ? new Set([...formData.keys()].filter((key) => !key.startsWith('__superform_')))\n        : new Set([\n            ...Object.keys(schema.properties ?? {}),\n            ...(schema.additionalProperties ? formData.keys() : [])\n        ].filter((key) => !key.startsWith('__superform_')));\n    function parseSingleEntry(key, entry, info) {\n        if (options?.preprocessed && options.preprocessed.includes(key)) {\n            return entry;\n        }\n        if (entry && typeof entry !== 'string') {\n            const allowFiles = legacyMode ? options?.allowFiles === true : options?.allowFiles !== false;\n            return !allowFiles ? undefined : entry.size ? entry : info.isNullable ? null : undefined;\n        }\n        if (info.types.length > 1) {\n            throw new SchemaError(unionError, key);\n        }\n        const [type] = info.types;\n        return parseFormDataEntry(key, entry, type ?? 'any', info);\n    }\n    const defaultPropertyType = typeof schema.additionalProperties == 'object'\n        ? schema.additionalProperties\n        : { type: 'string' };\n    for (const key of schemaKeys) {\n        const property = schema.properties\n            ? schema.properties[key]\n            : defaultPropertyType;\n        assertSchema(property, key);\n        const info = schemaInfo(property ?? defaultPropertyType, !schema.required?.includes(key), [\n            key\n        ]);\n        if (!info)\n            continue;\n        if (!info.types.includes('boolean') && !schema.additionalProperties && !formData.has(key)) {\n            continue;\n        }\n        const entries = formData.getAll(key);\n        if (info.union && info.union.length > 1) {\n            throw new SchemaError(unionError, key);\n        }\n        if (info.types.includes('array') || info.types.includes('set')) {\n            const items = property.items;\n            if (!items || typeof items == 'boolean' || (Array.isArray(items) && items.length != 1)) {\n                throw new SchemaError('Arrays must have a single \"items\" property that defines its type.', key);\n            }\n            const arrayType = Array.isArray(items) ? items[0] : items;\n            assertSchema(arrayType, key);\n            const arrayInfo = schemaInfo(arrayType, info.isOptional, [key]);\n            if (!arrayInfo)\n                continue;\n            const arrayData = entries.map((e) => parseSingleEntry(key, e, arrayInfo));\n            output[key] = info.types.includes('set') ? new Set(arrayData) : arrayData;\n        }\n        else {\n            output[key] = parseSingleEntry(key, entries[entries.length - 1], info);\n        }\n    }\n    return output;\n}\nfunction parseFormDataEntry(key, value, type, info) {\n    if (!value) {\n        //console.log(`No FormData for \"${key}\" (${type}).`, info); //debug\n        // Special case for booleans with default value true\n        if (type == 'boolean' && info.isOptional && info.schema.default === true) {\n            return false;\n        }\n        const defaultValue = defaultValues(info.schema, info.isOptional, [key]);\n        // Special case for empty posted enums, then the empty value should be returned,\n        // otherwise even a required field will get a default value, resulting in that\n        // posting missing enum values must use strict mode.\n        if (info.schema.enum && defaultValue !== null && defaultValue !== undefined) {\n            return value;\n        }\n        if (defaultValue !== undefined)\n            return defaultValue;\n        if (info.isNullable)\n            return null;\n        if (info.isOptional)\n            return undefined;\n    }\n    function typeError() {\n        throw new SchemaError(type[0].toUpperCase() +\n            type.slice(1) +\n            ` type found. ` +\n            `Set the dataType option to \"json\" and add use:enhance on the client to use nested data structures. ` +\n            `More information: https://superforms.rocks/concepts/nested-data`, key);\n    }\n    switch (type) {\n        case 'string':\n        case 'any':\n            return value;\n        case 'integer':\n            return parseInt(value ?? '', 10);\n        case 'number':\n            return parseFloat(value ?? '');\n        case 'boolean':\n            return Boolean(value == 'false' ? '' : value).valueOf();\n        case 'unix-time': {\n            // Must return undefined for invalid dates due to https://github.com/Rich-Harris/devalue/issues/51\n            const date = new Date(value ?? '');\n            return !isNaN(date) ? date : undefined;\n        }\n        case 'bigint':\n            return BigInt(value ?? '.');\n        case 'symbol':\n            return Symbol(String(value));\n        case 'set':\n        case 'array':\n        case 'object':\n            return typeError();\n        default:\n            throw new SuperFormError('Unsupported schema type for FormData: ' + type);\n    }\n}\n", "import SuperDebug from './client/SuperDebug.svelte';\nexport default SuperDebug;\nexport { SuperFormError, SchemaError } from './errors.js';\n// Everything from client/index.ts\nexport { superForm, intProxy, numberProxy, booleanProxy, dateProxy, fieldProxy, formFieldProxy, stringProxy, arrayProxy, defaults, defaultValues, schemaShape, actionResult, superValidate, message, setMessage, setError, withFiles, removeFiles } from './client/index.js';\nexport { splitPath } from './stringPath.js';\n"],
  "mappings": "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",
  "names": ["ctx", "file", "status", "data", "json", "page", "browser", "browser", "message", "file", "FetchStatus", "Form", "superForm", "path", "isSuperForm", "page", "browser", "_a", "Form", "options", "message", "errors", "form", "file", "cancelled", "cancel", "_b", "event", "data", "defaultValues", "legacyMode", "path", "defaults", "message"]
}
